diff --git a/fs/namespace.c b/fs/namespace.c
index 1077a6f..ff306c6 100644
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@ -40,6 +40,7 @@
 #ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
 extern bool susfs_is_current_ksu_domain(void);
 extern bool susfs_is_current_zygote_domain(void);
+extern bool susfs_is_boot_completed_triggered;
 
 static DEFINE_IDA(susfs_mnt_id_ida);
 static DEFINE_IDA(susfs_mnt_group_ida);
@@ -129,10 +130,10 @@ static inline struct hlist_head *mp_hash(struct dentry *dentry)
 }
 
 #ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
-// Our own mnt_alloc_id() that assigns mnt_id starting from DEFAULT_SUS_MNT_ID
+// Our own mnt_alloc_id() that assigns mnt_id starting from DEFAULT_KSU_MNT_ID
 static int susfs_mnt_alloc_id(struct mount *mnt)
 {
-	int res = ida_alloc_min(&susfs_mnt_id_ida, DEFAULT_SUS_MNT_ID, GFP_KERNEL);
+	int res = ida_alloc_min(&susfs_mnt_id_ida, DEFAULT_KSU_MNT_ID, GFP_KERNEL);
 
 	if (res < 0)
 		return res;
@@ -153,13 +154,13 @@ static int mnt_alloc_id(struct mount *mnt)
 static void mnt_free_id(struct mount *mnt)
 {
 #ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
-	// We should first check the 'mnt->mnt.susfs_mnt_id_backup', see if it is DEFAULT_SUS_MNT_ID_FOR_KSU_PROC_UNSHARE
+	// We should first check the 'mnt->mnt.susfs_mnt_id_backup', see if it is DEFAULT_KSU_MNT_ID_FOR_KSU_PROC_UNSHARE
 	// if so, these mnt_id were not assigned by mnt_alloc_id() so we don't need to free it.
-	if (unlikely(mnt->mnt.susfs_mnt_id_backup == DEFAULT_SUS_MNT_ID_FOR_KSU_PROC_UNSHARE)) {
+	if (unlikely(mnt->mnt.susfs_mnt_id_backup == DEFAULT_KSU_MNT_ID_FOR_KSU_PROC_UNSHARE)) {
 		return;
 	}
 	// Now we can check if its mnt_id is sus
-	if (unlikely(mnt->mnt_id >= DEFAULT_SUS_MNT_ID)) {
+	if (unlikely(mnt->mnt_id >= DEFAULT_KSU_MNT_ID)) {
 		ida_free(&susfs_mnt_id_ida, mnt->mnt_id);
 		return;
 	}
@@ -184,9 +185,9 @@ static int mnt_alloc_group_id(struct mount *mnt)
 	int res;
 
 	// Check if mnt has sus mnt_id
-	if (mnt->mnt_id >= DEFAULT_SUS_MNT_ID) {
-		// If so, assign a sus mnt_group id DEFAULT_SUS_MNT_GROUP_ID from susfs_mnt_group_ida
-		res = ida_alloc_min(&susfs_mnt_group_ida, DEFAULT_SUS_MNT_GROUP_ID, GFP_KERNEL);
+	if (mnt->mnt_id >= DEFAULT_KSU_MNT_ID) {
+		// If so, assign a sus mnt_group id DEFAULT_KSU_MNT_GROUP_ID from susfs_mnt_group_ida
+		res = ida_alloc_min(&susfs_mnt_group_ida, DEFAULT_KSU_MNT_GROUP_ID, GFP_KERNEL);
 		goto bypass_orig_flow;
 	}
 	res = ida_alloc_min(&mnt_group_ida, 1, GFP_KERNEL);
@@ -207,9 +208,9 @@ bypass_orig_flow:
 void mnt_release_group_id(struct mount *mnt)
 {
 #ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
-	// If mnt->mnt_group_id >= DEFAULT_SUS_MNT_GROUP_ID, it means 'mnt' is also sus mount,
+	// If mnt->mnt_group_id >= DEFAULT_KSU_MNT_GROUP_ID, it means 'mnt' is also sus mount,
 	// then we free the mnt->mnt_group_id from susfs_mnt_group_ida
-	if (mnt->mnt_group_id >= DEFAULT_SUS_MNT_GROUP_ID) {
+	if (mnt->mnt_group_id >= DEFAULT_KSU_MNT_GROUP_ID) {
 		ida_free(&susfs_mnt_group_ida, mnt->mnt_group_id);
 		mnt->mnt_group_id = 0;
 		return;
@@ -1088,7 +1089,7 @@ bypass_orig_flow:
 			rcu_read_lock();
 			mnt_id = list_first_entry(&mnt_ns->list, struct mount, mnt_list)->mnt_id;
 			list_for_each_entry_rcu(m, &mnt_ns->list, mnt_list) {
-				if (m->mnt_id < DEFAULT_SUS_MNT_ID) {
+				if (m->mnt_id < DEFAULT_KSU_MNT_ID) {
 					mnt_id++;
 				}
 			}
@@ -1202,12 +1203,12 @@ static struct mount *clone_mnt(struct mount *old, struct dentry *root,
 		// if it is doing unshare
 		mnt = alloc_vfsmnt(old->mnt_devname, true, old->mnt_id);
 		if (mnt) {
-			mnt->mnt.susfs_mnt_id_backup = DEFAULT_SUS_MNT_ID_FOR_KSU_PROC_UNSHARE;
+			mnt->mnt.susfs_mnt_id_backup = DEFAULT_KSU_MNT_ID_FOR_KSU_PROC_UNSHARE;
 		}
 		goto bypass_orig_flow;
 	}
 	// Lastly, just check if old->mnt_id is sus
-	if (old->mnt_id >= DEFAULT_SUS_MNT_ID) {
+	if (old->mnt_id >= DEFAULT_KSU_MNT_ID) {
 		mnt = alloc_vfsmnt(old->mnt_devname, true, 0);
 		goto bypass_orig_flow;
 	}
@@ -1260,7 +1261,7 @@ bypass_orig_flow:
 			rcu_read_lock();
 			mnt_id = list_first_entry(&mnt_ns->list, struct mount, mnt_list)->mnt_id;
 			list_for_each_entry_rcu(m, &mnt_ns->list, mnt_list) {
-				if (m->mnt_id < DEFAULT_SUS_MNT_ID) {
+				if (m->mnt_id < DEFAULT_KSU_MNT_ID) {
 					mnt_id++;
 				}
 			}
@@ -2091,7 +2092,7 @@ struct mount *copy_tree(struct mount *mnt, struct dentry *dentry,
 				goto out;
 #ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
             if (is_zygote_not_copy_mnt_ns &&
-				q->mnt_id < DEFAULT_SUS_MNT_ID) {
+				q->mnt_id < DEFAULT_KSU_MNT_ID) {
 					attach_mnt_count++;
 					q->mnt_id += attach_mnt_count;
 			}
@@ -3643,7 +3644,7 @@ struct mnt_namespace *copy_mnt_ns(unsigned long flags, struct mnt_namespace *ns,
 			break;
 #ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
 		// Here We are only interested in processes of which original mnt namespace belongs to zygote
-		if (likely(is_zygote_pid && (q->mnt_id < DEFAULT_SUS_MNT_ID))) {
+		if (likely(is_zygote_pid && (q->mnt_id < DEFAULT_KSU_MNT_ID))) {
 			// q->mnt.susfs_mnt_id_backup -> original mnt_id
 			// q->mnt_id -> to be modified to the fake mnt_id
 			q->mnt.susfs_mnt_id_backup = q->mnt_id;
@@ -4411,7 +4412,7 @@ void susfs_run_try_umount_for_current_mnt_ns(void) {
        namespace_lock();
        list_for_each_entry(mnt, &mnt_ns->list, mnt_list) {
                // Change the sus mount to be private
-               if (mnt->mnt_id >= DEFAULT_SUS_MNT_ID) {
+               if (mnt->mnt_id >= DEFAULT_KSU_MNT_ID) {
                        change_mnt_propagation(mnt, MS_PRIVATE);
                }
        }
@@ -4420,6 +4421,26 @@ void susfs_run_try_umount_for_current_mnt_ns(void) {
        susfs_try_umount_all(current_uid().val);
 }
 #endif
+#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
+/* Reorder the mnt_id after all sus mounts are umounted during ksu_handle_setuid() */
+void susfs_reorder_mnt_id(void) {
+	struct mnt_namespace *mnt_ns = current->nsproxy->mnt_ns;
+	struct mount *mnt;
+	int first_mnt_id = 0;
+
+	if (!mnt_ns) {
+		return;
+	}
+
+	get_mnt_ns(mnt_ns);
+	first_mnt_id = list_first_entry(&mnt_ns->list, struct mount, mnt_list)->mnt_id;
+	list_for_each_entry(mnt, &mnt_ns->list, mnt_list) {
+		mnt->mnt.susfs_mnt_id_backup = mnt->mnt_id;
+		mnt->mnt_id = first_mnt_id++;
+	}
+	put_mnt_ns(mnt_ns);
+}
+#endif
 #ifdef CONFIG_KSU_SUSFS
 bool susfs_is_mnt_devname_ksu(struct path *path) {
 	struct mount *mnt;
diff --git a/fs/notify/fdinfo.c b/fs/notify/fdinfo.c
index 6dd4ce0..d7e0608 100644
--- a/fs/notify/fdinfo.c
+++ b/fs/notify/fdinfo.c
@@ -103,7 +103,7 @@ static void inotify_fdinfo(struct seq_file *m, struct fsnotify_mark *mark)
 	inode = igrab(fsnotify_conn_inode(mark->connector));
 	if (inode) {
 #ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
-		if (likely(susfs_is_current_non_root_user_app_proc()) &&
+		if (likely(susfs_is_current_proc_umounted()) &&
 				unlikely(inode->i_mapping->flags & BIT_SUS_KSTAT)) {
 			struct path path;
 			char *pathname = kmalloc(PAGE_SIZE, GFP_KERNEL);
diff --git a/fs/proc/fd.c b/fs/proc/fd.c
index 4a74eb2..0e8874d 100644
--- a/fs/proc/fd.c
+++ b/fs/proc/fd.c
@@ -60,13 +60,13 @@ static int seq_show(struct seq_file *m, void *v)
 		return ret;
 #ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
 	mnt = real_mount(file->f_path.mnt);
-	if (likely(susfs_is_current_non_root_user_app_proc()) &&
-			mnt->mnt_id >= DEFAULT_SUS_MNT_ID) {
+	if (likely(susfs_is_current_proc_umounted()) &&
+			mnt->mnt_id >= DEFAULT_KSU_MNT_ID) {
 		struct path path;
 		char *pathname = kmalloc(PAGE_SIZE, GFP_KERNEL);
 		char *dpath;
 
-		for (; mnt->mnt_id >= DEFAULT_SUS_MNT_ID; mnt = mnt->mnt_parent) { }
+		for (; mnt->mnt_id >= DEFAULT_KSU_MNT_ID; mnt = mnt->mnt_parent) { }
 
 		if (!pathname) {
 			goto out_seq_printf;
diff --git a/fs/proc_namespace.c b/fs/proc_namespace.c
index 994bd83..74ac89b 100644
--- a/fs/proc_namespace.c
+++ b/fs/proc_namespace.c
@@ -110,7 +110,7 @@ static int show_vfsmnt(struct seq_file *m, struct vfsmount *mnt)
 	int err;
 
 #ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
-	if (susfs_hide_sus_mnts_for_all_procs && r->mnt_id >= DEFAULT_SUS_MNT_ID)
+	if (susfs_hide_sus_mnts_for_all_procs && r->mnt_id >= DEFAULT_KSU_MNT_ID)
 		return 0;
 #endif
 
@@ -151,7 +151,7 @@ static int show_mountinfo(struct seq_file *m, struct vfsmount *mnt)
 	int err;
 
 #ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
-	if (susfs_hide_sus_mnts_for_all_procs && r->mnt_id >= DEFAULT_SUS_MNT_ID)
+	if (susfs_hide_sus_mnts_for_all_procs && r->mnt_id >= DEFAULT_KSU_MNT_ID)
 		return 0;
 #endif
 
@@ -220,7 +220,7 @@ static int show_vfsstat(struct seq_file *m, struct vfsmount *mnt)
 	int err;
 
 #ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
-	if (susfs_hide_sus_mnts_for_all_procs && r->mnt_id >= DEFAULT_SUS_MNT_ID)
+	if (susfs_hide_sus_mnts_for_all_procs && r->mnt_id >= DEFAULT_KSU_MNT_ID)
 		return 0;
 #endif
 
diff --git a/fs/stat.c b/fs/stat.c
index 4956295..2138195 100644
--- a/fs/stat.c
+++ b/fs/stat.c
@@ -40,7 +40,7 @@ extern void susfs_sus_ino_for_generic_fillattr(unsigned long ino, struct kstat *
 void generic_fillattr(struct inode *inode, struct kstat *stat)
 {
 #ifdef CONFIG_KSU_SUSFS_SUS_KSTAT
-	if (likely(susfs_is_current_non_root_user_app_proc()) &&
+	if (likely(susfs_is_current_proc_umounted()) &&
 			unlikely(inode->i_mapping->flags & BIT_SUS_KSTAT)) {
 		susfs_sus_ino_for_generic_fillattr(inode->i_ino, stat);
 		stat->mode = inode->i_mode;
diff --git a/fs/statfs.c b/fs/statfs.c
index 9c1fa9c..ca59fd5 100644
--- a/fs/statfs.c
+++ b/fs/statfs.c
@@ -92,8 +92,8 @@ int vfs_statfs(const struct path *path, struct kstatfs *buf)
 	struct mount *mnt;
 
 	mnt = real_mount(path->mnt);
-	if (likely(susfs_is_current_non_root_user_app_proc())) {
-		for (; mnt->mnt_id >= DEFAULT_SUS_MNT_ID; mnt = mnt->mnt_parent) {}
+	if (likely(susfs_is_current_proc_umounted())) {
+		for (; mnt->mnt_id >= DEFAULT_KSU_MNT_ID; mnt = mnt->mnt_parent) {}
 	}
 	error = statfs_by_dentry(mnt->mnt.mnt_root, buf);
 	if (!error)
diff --git a/fs/susfs.c b/fs/susfs.c
index f3b34d2..6d8eaa0 100644
--- a/fs/susfs.c
+++ b/fs/susfs.c
@@ -354,16 +354,16 @@ void susfs_run_sus_path_loop(uid_t uid) {
 }
 
 static inline bool is_i_uid_in_android_data_not_allowed(uid_t i_uid) {
-	return (likely(susfs_is_current_non_root_user_app_proc()) &&
+	return (likely(susfs_is_current_proc_umounted()) &&
 		unlikely(current_uid().val != i_uid));
 }
 
 static inline bool is_i_uid_in_sdcard_not_allowed(void) {
-	return (likely(susfs_is_current_non_root_user_app_proc()));
+	return (likely(susfs_is_current_proc_umounted()));
 }
 
 static inline bool is_i_uid_not_allowed(uid_t i_uid) {
-	return (likely(susfs_is_current_non_root_user_app_proc()) &&
+	return (likely(susfs_is_current_proc_umounted()) &&
 		unlikely(current_uid().val != i_uid));
 }
 
@@ -471,7 +471,7 @@ static void susfs_update_sus_mount_inode(char *target_pathname) {
 	 */
 	mnt = real_mount(p.mnt);
 	if (mnt->mnt_group_id > 0 && // 0 means no peer group
-		mnt->mnt_group_id < DEFAULT_SUS_MNT_GROUP_ID) {
+		mnt->mnt_group_id < DEFAULT_KSU_MNT_GROUP_ID) {
 		SUSFS_LOGE("skip setting SUS_MOUNT inode state for path '%s' since its source mount has a legit peer group id\n", target_pathname);
 		return;
 	}
@@ -548,7 +548,7 @@ int susfs_auto_add_sus_bind_mount(const char *pathname, struct path *path_target
 
 	mnt = real_mount(path_target->mnt);
 	if (mnt->mnt_group_id > 0 && // 0 means no peer group
-		mnt->mnt_group_id < DEFAULT_SUS_MNT_GROUP_ID) {
+		mnt->mnt_group_id < DEFAULT_KSU_MNT_GROUP_ID) {
 		SUSFS_LOGE("skip setting SUS_MOUNT inode state for path '%s' since its source mount has a legit peer group id\n", pathname);
 		// return 0 here as we still want it to be added to try_umount list
 		return 0;
diff --git a/include/linux/susfs.h b/include/linux/susfs.h
index c2e8bb9..c4167fd 100644
--- a/include/linux/susfs.h
+++ b/include/linux/susfs.h
@@ -8,7 +8,7 @@
 #include <linux/path.h>
 #include <linux/susfs_def.h>
 
-#define SUSFS_VERSION "v1.5.10"
+#define SUSFS_VERSION "v1.5.11"
 #if LINUX_VERSION_CODE < KERNEL_VERSION(5,0,0)
 #define SUSFS_VARIANT "NON-GKI"
 #else
diff --git a/include/linux/susfs_def.h b/include/linux/susfs_def.h
index c34f6ef..5d4f72d 100644
--- a/include/linux/susfs_def.h
+++ b/include/linux/susfs_def.h
@@ -33,17 +33,16 @@
 #define TRY_UMOUNT_DEFAULT 0 /* used by susfs_try_umount() */
 #define TRY_UMOUNT_DETACH 1 /* used by susfs_try_umount() */
 
-#define DEFAULT_SUS_MNT_ID 100000 /* used by mount->mnt_id */
-#define DEFAULT_SUS_MNT_ID_FOR_KSU_PROC_UNSHARE 1000000 /* used by vfsmount->susfs_mnt_id_backup */
-#define DEFAULT_SUS_MNT_GROUP_ID 1000 /* used by mount->mnt_group_id */
+#define DEFAULT_KSU_MNT_ID 300000 /* used by mount->mnt_id */
+#define DEFAULT_KSU_MNT_ID_FOR_KSU_PROC_UNSHARE 1000000 /* used by vfsmount->susfs_mnt_id_backup */
+#define DEFAULT_KSU_MNT_GROUP_ID 3000 /* used by mount->mnt_group_id */
 
 /*
  * mount->mnt.susfs_mnt_id_backup => storing original mnt_id of normal mounts or custom sus mnt_id of sus mounts
  * task_struct->susfs_task_state => storing flag 'TASK_STRUCT_'
  */
 
-#define TIF_NON_ROOT_USER_APP_PROC 33 // thread_info->flags is unsigned long :D
-#define TIF_PROC_SU_NOT_ALLOWED 34
+#define TIF_PROC_UMOUNTED 33
 
 #define AS_FLAGS_SUS_PATH 24
 #define AS_FLAGS_SUS_MOUNT 25
@@ -69,20 +68,12 @@
 #define DATA_ADB_NO_AUTO_ADD_SUS_KSU_DEFAULT_MOUNT "/data/adb/susfs_no_auto_add_sus_ksu_default_mount"
 #define DATA_ADB_NO_AUTO_ADD_TRY_UMOUNT_FOR_BIND_MOUNT "/data/adb/susfs_no_auto_add_try_umount_for_bind_mount"
 
-static inline bool susfs_is_current_non_root_user_app_proc(void) {
-	return test_ti_thread_flag(&current->thread_info, TIF_NON_ROOT_USER_APP_PROC);
+static inline bool susfs_is_current_proc_umounted(void) {
+	return test_ti_thread_flag(&current->thread_info, TIF_PROC_UMOUNTED);
 }
 
-static inline void susfs_set_current_non_root_user_app_proc(void) {
-	set_ti_thread_flag(&current->thread_info, TIF_NON_ROOT_USER_APP_PROC);
-}
-
-static inline bool susfs_is_current_proc_su_not_allowed(void) {
-	return test_ti_thread_flag(&current->thread_info, TIF_PROC_SU_NOT_ALLOWED);
-}
-
-static inline void susfs_set_current_proc_su_not_allowed(void) {
-	set_ti_thread_flag(&current->thread_info, TIF_PROC_SU_NOT_ALLOWED);
+static inline void susfs_set_current_proc_umounted(void) {
+	set_ti_thread_flag(&current->thread_info, TIF_PROC_UMOUNTED);
 }
 
 #endif // #ifndef KSU_SUSFS_DEF_H
diff --git a/susfs4ksu/.git/HEAD b/susfs4ksu/.git/HEAD
deleted file mode 100644
index 0d7e9eb..0000000
--- a/susfs4ksu/.git/HEAD
+++ /dev/null
@@ -1 +0,0 @@
-ref: refs/heads/kernel-5.4
diff --git a/susfs4ksu/.git/config b/susfs4ksu/.git/config
deleted file mode 100644
index 03c9786..0000000
--- a/susfs4ksu/.git/config
+++ /dev/null
@@ -1,11 +0,0 @@
-[core]
-	repositoryformatversion = 0
-	filemode = true
-	bare = false
-	logallrefupdates = true
-[remote "origin"]
-	url = https://gitlab.com/simonpunk/susfs4ksu.git
-	fetch = +refs/heads/*:refs/remotes/origin/*
-[branch "kernel-5.4"]
-	remote = origin
-	merge = refs/heads/kernel-5.4
diff --git a/susfs4ksu/.git/description b/susfs4ksu/.git/description
deleted file mode 100644
index 498b267..0000000
--- a/susfs4ksu/.git/description
+++ /dev/null
@@ -1 +0,0 @@
-Unnamed repository; edit this file 'description' to name the repository.
diff --git a/susfs4ksu/.git/hooks/applypatch-msg.sample b/susfs4ksu/.git/hooks/applypatch-msg.sample
deleted file mode 100755
index a5d7b84..0000000
--- a/susfs4ksu/.git/hooks/applypatch-msg.sample
+++ /dev/null
@@ -1,15 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to check the commit log message taken by
-# applypatch from an e-mail message.
-#
-# The hook should exit with non-zero status after issuing an
-# appropriate message if it wants to stop the commit.  The hook is
-# allowed to edit the commit message file.
-#
-# To enable this hook, rename this file to "applypatch-msg".
-
-. git-sh-setup
-commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
-test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
-:
diff --git a/susfs4ksu/.git/hooks/commit-msg.sample b/susfs4ksu/.git/hooks/commit-msg.sample
deleted file mode 100755
index b58d118..0000000
--- a/susfs4ksu/.git/hooks/commit-msg.sample
+++ /dev/null
@@ -1,24 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to check the commit log message.
-# Called by "git commit" with one argument, the name of the file
-# that has the commit message.  The hook should exit with non-zero
-# status after issuing an appropriate message if it wants to stop the
-# commit.  The hook is allowed to edit the commit message file.
-#
-# To enable this hook, rename this file to "commit-msg".
-
-# Uncomment the below to add a Signed-off-by line to the message.
-# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
-# hook is more suited to it.
-#
-# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
-# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
-
-# This example catches duplicate Signed-off-by lines.
-
-test "" = "$(grep '^Signed-off-by: ' "$1" |
-	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
-	echo >&2 Duplicate Signed-off-by lines.
-	exit 1
-}
diff --git a/susfs4ksu/.git/hooks/fsmonitor-watchman.sample b/susfs4ksu/.git/hooks/fsmonitor-watchman.sample
deleted file mode 100755
index 23e856f..0000000
--- a/susfs4ksu/.git/hooks/fsmonitor-watchman.sample
+++ /dev/null
@@ -1,174 +0,0 @@
-#!/usr/bin/perl
-
-use strict;
-use warnings;
-use IPC::Open2;
-
-# An example hook script to integrate Watchman
-# (https://facebook.github.io/watchman/) with git to speed up detecting
-# new and modified files.
-#
-# The hook is passed a version (currently 2) and last update token
-# formatted as a string and outputs to stdout a new update token and
-# all files that have been modified since the update token. Paths must
-# be relative to the root of the working tree and separated by a single NUL.
-#
-# To enable this hook, rename this file to "query-watchman" and set
-# 'git config core.fsmonitor .git/hooks/query-watchman'
-#
-my ($version, $last_update_token) = @ARGV;
-
-# Uncomment for debugging
-# print STDERR "$0 $version $last_update_token\n";
-
-# Check the hook interface version
-if ($version ne 2) {
-	die "Unsupported query-fsmonitor hook version '$version'.\n" .
-	    "Falling back to scanning...\n";
-}
-
-my $git_work_tree = get_working_dir();
-
-my $retry = 1;
-
-my $json_pkg;
-eval {
-	require JSON::XS;
-	$json_pkg = "JSON::XS";
-	1;
-} or do {
-	require JSON::PP;
-	$json_pkg = "JSON::PP";
-};
-
-launch_watchman();
-
-sub launch_watchman {
-	my $o = watchman_query();
-	if (is_work_tree_watched($o)) {
-		output_result($o->{clock}, @{$o->{files}});
-	}
-}
-
-sub output_result {
-	my ($clockid, @files) = @_;
-
-	# Uncomment for debugging watchman output
-	# open (my $fh, ">", ".git/watchman-output.out");
-	# binmode $fh, ":utf8";
-	# print $fh "$clockid\n@files\n";
-	# close $fh;
-
-	binmode STDOUT, ":utf8";
-	print $clockid;
-	print "\0";
-	local $, = "\0";
-	print @files;
-}
-
-sub watchman_clock {
-	my $response = qx/watchman clock "$git_work_tree"/;
-	die "Failed to get clock id on '$git_work_tree'.\n" .
-		"Falling back to scanning...\n" if $? != 0;
-
-	return $json_pkg->new->utf8->decode($response);
-}
-
-sub watchman_query {
-	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
-	or die "open2() failed: $!\n" .
-	"Falling back to scanning...\n";
-
-	# In the query expression below we're asking for names of files that
-	# changed since $last_update_token but not from the .git folder.
-	#
-	# To accomplish this, we're using the "since" generator to use the
-	# recency index to select candidate nodes and "fields" to limit the
-	# output to file names only. Then we're using the "expression" term to
-	# further constrain the results.
-	my $last_update_line = "";
-	if (substr($last_update_token, 0, 1) eq "c") {
-		$last_update_token = "\"$last_update_token\"";
-		$last_update_line = qq[\n"since": $last_update_token,];
-	}
-	my $query = <<"	END";
-		["query", "$git_work_tree", {$last_update_line
-			"fields": ["name"],
-			"expression": ["not", ["dirname", ".git"]]
-		}]
-	END
-
-	# Uncomment for debugging the watchman query
-	# open (my $fh, ">", ".git/watchman-query.json");
-	# print $fh $query;
-	# close $fh;
-
-	print CHLD_IN $query;
-	close CHLD_IN;
-	my $response = do {local $/; <CHLD_OUT>};
-
-	# Uncomment for debugging the watch response
-	# open ($fh, ">", ".git/watchman-response.json");
-	# print $fh $response;
-	# close $fh;
-
-	die "Watchman: command returned no output.\n" .
-	"Falling back to scanning...\n" if $response eq "";
-	die "Watchman: command returned invalid output: $response\n" .
-	"Falling back to scanning...\n" unless $response =~ /^\{/;
-
-	return $json_pkg->new->utf8->decode($response);
-}
-
-sub is_work_tree_watched {
-	my ($output) = @_;
-	my $error = $output->{error};
-	if ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {
-		$retry--;
-		my $response = qx/watchman watch "$git_work_tree"/;
-		die "Failed to make watchman watch '$git_work_tree'.\n" .
-		    "Falling back to scanning...\n" if $? != 0;
-		$output = $json_pkg->new->utf8->decode($response);
-		$error = $output->{error};
-		die "Watchman: $error.\n" .
-		"Falling back to scanning...\n" if $error;
-
-		# Uncomment for debugging watchman output
-		# open (my $fh, ">", ".git/watchman-output.out");
-		# close $fh;
-
-		# Watchman will always return all files on the first query so
-		# return the fast "everything is dirty" flag to git and do the
-		# Watchman query just to get it over with now so we won't pay
-		# the cost in git to look up each individual file.
-		my $o = watchman_clock();
-		$error = $output->{error};
-
-		die "Watchman: $error.\n" .
-		"Falling back to scanning...\n" if $error;
-
-		output_result($o->{clock}, ("/"));
-		$last_update_token = $o->{clock};
-
-		eval { launch_watchman() };
-		return 0;
-	}
-
-	die "Watchman: $error.\n" .
-	"Falling back to scanning...\n" if $error;
-
-	return 1;
-}
-
-sub get_working_dir {
-	my $working_dir;
-	if ($^O =~ 'msys' || $^O =~ 'cygwin') {
-		$working_dir = Win32::GetCwd();
-		$working_dir =~ tr/\\/\//;
-	} else {
-		require Cwd;
-		$working_dir = Cwd::cwd();
-	}
-
-	return $working_dir;
-}
diff --git a/susfs4ksu/.git/hooks/post-update.sample b/susfs4ksu/.git/hooks/post-update.sample
deleted file mode 100755
index ec17ec1..0000000
--- a/susfs4ksu/.git/hooks/post-update.sample
+++ /dev/null
@@ -1,8 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to prepare a packed repository for use over
-# dumb transports.
-#
-# To enable this hook, rename this file to "post-update".
-
-exec git update-server-info
diff --git a/susfs4ksu/.git/hooks/pre-applypatch.sample b/susfs4ksu/.git/hooks/pre-applypatch.sample
deleted file mode 100755
index 4142082..0000000
--- a/susfs4ksu/.git/hooks/pre-applypatch.sample
+++ /dev/null
@@ -1,14 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to verify what is about to be committed
-# by applypatch from an e-mail message.
-#
-# The hook should exit with non-zero status after issuing an
-# appropriate message if it wants to stop the commit.
-#
-# To enable this hook, rename this file to "pre-applypatch".
-
-. git-sh-setup
-precommit="$(git rev-parse --git-path hooks/pre-commit)"
-test -x "$precommit" && exec "$precommit" ${1+"$@"}
-:
diff --git a/susfs4ksu/.git/hooks/pre-commit.sample b/susfs4ksu/.git/hooks/pre-commit.sample
deleted file mode 100755
index 29ed5ee..0000000
--- a/susfs4ksu/.git/hooks/pre-commit.sample
+++ /dev/null
@@ -1,49 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to verify what is about to be committed.
-# Called by "git commit" with no arguments.  The hook should
-# exit with non-zero status after issuing an appropriate message if
-# it wants to stop the commit.
-#
-# To enable this hook, rename this file to "pre-commit".
-
-if git rev-parse --verify HEAD >/dev/null 2>&1
-then
-	against=HEAD
-else
-	# Initial commit: diff against an empty tree object
-	against=$(git hash-object -t tree /dev/null)
-fi
-
-# If you want to allow non-ASCII filenames set this variable to true.
-allownonascii=$(git config --type=bool hooks.allownonascii)
-
-# Redirect output to stderr.
-exec 1>&2
-
-# Cross platform projects tend to avoid non-ASCII filenames; prevent
-# them from being added to the repository. We exploit the fact that the
-# printable range starts at the space character and ends with tilde.
-if [ "$allownonascii" != "true" ] &&
-	# Note that the use of brackets around a tr range is ok here, (it's
-	# even required, for portability to Solaris 10's /usr/bin/tr), since
-	# the square bracket bytes happen to fall in the designated range.
-	test $(git diff-index --cached --name-only --diff-filter=A -z $against |
-	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
-then
-	cat <<\EOF
-Error: Attempt to add a non-ASCII file name.
-
-This can cause problems if you want to work with people on other platforms.
-
-To be portable it is advisable to rename the file.
-
-If you know what you are doing you can disable this check using:
-
-  git config hooks.allownonascii true
-EOF
-	exit 1
-fi
-
-# If there are whitespace errors, print the offending file names and fail.
-exec git diff-index --check --cached $against --
diff --git a/susfs4ksu/.git/hooks/pre-merge-commit.sample b/susfs4ksu/.git/hooks/pre-merge-commit.sample
deleted file mode 100755
index 399eab1..0000000
--- a/susfs4ksu/.git/hooks/pre-merge-commit.sample
+++ /dev/null
@@ -1,13 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to verify what is about to be committed.
-# Called by "git merge" with no arguments.  The hook should
-# exit with non-zero status after issuing an appropriate message to
-# stderr if it wants to stop the merge commit.
-#
-# To enable this hook, rename this file to "pre-merge-commit".
-
-. git-sh-setup
-test -x "$GIT_DIR/hooks/pre-commit" &&
-        exec "$GIT_DIR/hooks/pre-commit"
-:
diff --git a/susfs4ksu/.git/hooks/pre-push.sample b/susfs4ksu/.git/hooks/pre-push.sample
deleted file mode 100755
index 4ce688d..0000000
--- a/susfs4ksu/.git/hooks/pre-push.sample
+++ /dev/null
@@ -1,53 +0,0 @@
-#!/bin/sh
-
-# An example hook script to verify what is about to be pushed.  Called by "git
-# push" after it has checked the remote status, but before anything has been
-# pushed.  If this script exits with a non-zero status nothing will be pushed.
-#
-# This hook is called with the following parameters:
-#
-# $1 -- Name of the remote to which the push is being done
-# $2 -- URL to which the push is being done
-#
-# If pushing without using a named remote those arguments will be equal.
-#
-# Information about the commits which are being pushed is supplied as lines to
-# the standard input in the form:
-#
-#   <local ref> <local oid> <remote ref> <remote oid>
-#
-# This sample shows how to prevent push of commits where the log message starts
-# with "WIP" (work in progress).
-
-remote="$1"
-url="$2"
-
-zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
-
-while read local_ref local_oid remote_ref remote_oid
-do
-	if test "$local_oid" = "$zero"
-	then
-		# Handle delete
-		:
-	else
-		if test "$remote_oid" = "$zero"
-		then
-			# New branch, examine all commits
-			range="$local_oid"
-		else
-			# Update to existing branch, examine new commits
-			range="$remote_oid..$local_oid"
-		fi
-
-		# Check for WIP commit
-		commit=$(git rev-list -n 1 --grep '^WIP' "$range")
-		if test -n "$commit"
-		then
-			echo >&2 "Found WIP commit in $local_ref, not pushing"
-			exit 1
-		fi
-	fi
-done
-
-exit 0
diff --git a/susfs4ksu/.git/hooks/pre-rebase.sample b/susfs4ksu/.git/hooks/pre-rebase.sample
deleted file mode 100755
index 6cbef5c..0000000
--- a/susfs4ksu/.git/hooks/pre-rebase.sample
+++ /dev/null
@@ -1,169 +0,0 @@
-#!/bin/sh
-#
-# Copyright (c) 2006, 2008 Junio C Hamano
-#
-# The "pre-rebase" hook is run just before "git rebase" starts doing
-# its job, and can prevent the command from running by exiting with
-# non-zero status.
-#
-# The hook is called with the following parameters:
-#
-# $1 -- the upstream the series was forked from.
-# $2 -- the branch being rebased (or empty when rebasing the current branch).
-#
-# This sample shows how to prevent topic branches that are already
-# merged to 'next' branch from getting rebased, because allowing it
-# would result in rebasing already published history.
-
-publish=next
-basebranch="$1"
-if test "$#" = 2
-then
-	topic="refs/heads/$2"
-else
-	topic=`git symbolic-ref HEAD` ||
-	exit 0 ;# we do not interrupt rebasing detached HEAD
-fi
-
-case "$topic" in
-refs/heads/??/*)
-	;;
-*)
-	exit 0 ;# we do not interrupt others.
-	;;
-esac
-
-# Now we are dealing with a topic branch being rebased
-# on top of master.  Is it OK to rebase it?
-
-# Does the topic really exist?
-git show-ref -q "$topic" || {
-	echo >&2 "No such branch $topic"
-	exit 1
-}
-
-# Is topic fully merged to master?
-not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
-if test -z "$not_in_master"
-then
-	echo >&2 "$topic is fully merged to master; better remove it."
-	exit 1 ;# we could allow it, but there is no point.
-fi
-
-# Is topic ever merged to next?  If so you should not be rebasing it.
-only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
-only_next_2=`git rev-list ^master           ${publish} | sort`
-if test "$only_next_1" = "$only_next_2"
-then
-	not_in_topic=`git rev-list "^$topic" master`
-	if test -z "$not_in_topic"
-	then
-		echo >&2 "$topic is already up to date with master"
-		exit 1 ;# we could allow it, but there is no point.
-	else
-		exit 0
-	fi
-else
-	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
-	/usr/bin/perl -e '
-		my $topic = $ARGV[0];
-		my $msg = "* $topic has commits already merged to public branch:\n";
-		my (%not_in_next) = map {
-			/^([0-9a-f]+) /;
-			($1 => 1);
-		} split(/\n/, $ARGV[1]);
-		for my $elem (map {
-				/^([0-9a-f]+) (.*)$/;
-				[$1 => $2];
-			} split(/\n/, $ARGV[2])) {
-			if (!exists $not_in_next{$elem->[0]}) {
-				if ($msg) {
-					print STDERR $msg;
-					undef $msg;
-				}
-				print STDERR " $elem->[1]\n";
-			}
-		}
-	' "$topic" "$not_in_next" "$not_in_master"
-	exit 1
-fi
-
-<<\DOC_END
-
-This sample hook safeguards topic branches that have been
-published from being rewound.
-
-The workflow assumed here is:
-
- * Once a topic branch forks from "master", "master" is never
-   merged into it again (either directly or indirectly).
-
- * Once a topic branch is fully cooked and merged into "master",
-   it is deleted.  If you need to build on top of it to correct
-   earlier mistakes, a new topic branch is created by forking at
-   the tip of the "master".  This is not strictly necessary, but
-   it makes it easier to keep your history simple.
-
- * Whenever you need to test or publish your changes to topic
-   branches, merge them into "next" branch.
-
-The script, being an example, hardcodes the publish branch name
-to be "next", but it is trivial to make it configurable via
-$GIT_DIR/config mechanism.
-
-With this workflow, you would want to know:
-
-(1) ... if a topic branch has ever been merged to "next".  Young
-    topic branches can have stupid mistakes you would rather
-    clean up before publishing, and things that have not been
-    merged into other branches can be easily rebased without
-    affecting other people.  But once it is published, you would
-    not want to rewind it.
-
-(2) ... if a topic branch has been fully merged to "master".
-    Then you can delete it.  More importantly, you should not
-    build on top of it -- other people may already want to
-    change things related to the topic as patches against your
-    "master", so if you need further changes, it is better to
-    fork the topic (perhaps with the same name) afresh from the
-    tip of "master".
-
-Let's look at this example:
-
-		   o---o---o---o---o---o---o---o---o---o "next"
-		  /       /           /           /
-		 /   a---a---b A     /           /
-		/   /               /           /
-	       /   /   c---c---c---c B         /
-	      /   /   /             \         /
-	     /   /   /   b---b C     \       /
-	    /   /   /   /             \     /
-    ---o---o---o---o---o---o---o---o---o---o---o "master"
-
-
-A, B and C are topic branches.
-
- * A has one fix since it was merged up to "next".
-
- * B has finished.  It has been fully merged up to "master" and "next",
-   and is ready to be deleted.
-
- * C has not merged to "next" at all.
-
-We would want to allow C to be rebased, refuse A, and encourage
-B to be deleted.
-
-To compute (1):
-
-	git rev-list ^master ^topic next
-	git rev-list ^master        next
-
-	if these match, topic has not merged in next at all.
-
-To compute (2):
-
-	git rev-list master..topic
-
-	if this is empty, it is fully merged to "master".
-
-DOC_END
diff --git a/susfs4ksu/.git/hooks/pre-receive.sample b/susfs4ksu/.git/hooks/pre-receive.sample
deleted file mode 100755
index a1fd29e..0000000
--- a/susfs4ksu/.git/hooks/pre-receive.sample
+++ /dev/null
@@ -1,24 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to make use of push options.
-# The example simply echoes all push options that start with 'echoback='
-# and rejects all pushes when the "reject" push option is used.
-#
-# To enable this hook, rename this file to "pre-receive".
-
-if test -n "$GIT_PUSH_OPTION_COUNT"
-then
-	i=0
-	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
-	do
-		eval "value=\$GIT_PUSH_OPTION_$i"
-		case "$value" in
-		echoback=*)
-			echo "echo from the pre-receive-hook: ${value#*=}" >&2
-			;;
-		reject)
-			exit 1
-		esac
-		i=$((i + 1))
-	done
-fi
diff --git a/susfs4ksu/.git/hooks/prepare-commit-msg.sample b/susfs4ksu/.git/hooks/prepare-commit-msg.sample
deleted file mode 100755
index 10fa14c..0000000
--- a/susfs4ksu/.git/hooks/prepare-commit-msg.sample
+++ /dev/null
@@ -1,42 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to prepare the commit log message.
-# Called by "git commit" with the name of the file that has the
-# commit message, followed by the description of the commit
-# message's source.  The hook's purpose is to edit the commit
-# message file.  If the hook fails with a non-zero status,
-# the commit is aborted.
-#
-# To enable this hook, rename this file to "prepare-commit-msg".
-
-# This hook includes three examples. The first one removes the
-# "# Please enter the commit message..." help message.
-#
-# The second includes the output of "git diff --name-status -r"
-# into the message, just before the "git status" output.  It is
-# commented because it doesn't cope with --amend or with squashed
-# commits.
-#
-# The third example adds a Signed-off-by line to the message, that can
-# still be edited.  This is rarely a good idea.
-
-COMMIT_MSG_FILE=$1
-COMMIT_SOURCE=$2
-SHA1=$3
-
-/usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' "$COMMIT_MSG_FILE"
-
-# case "$COMMIT_SOURCE,$SHA1" in
-#  ,|template,)
-#    /usr/bin/perl -i.bak -pe '
-#       print "\n" . `git diff --cached --name-status -r`
-# 	 if /^#/ && $first++ == 0' "$COMMIT_MSG_FILE" ;;
-#  *) ;;
-# esac
-
-# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
-# git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
-# if test -z "$COMMIT_SOURCE"
-# then
-#   /usr/bin/perl -i.bak -pe 'print "\n" if !$first_line++' "$COMMIT_MSG_FILE"
-# fi
diff --git a/susfs4ksu/.git/hooks/push-to-checkout.sample b/susfs4ksu/.git/hooks/push-to-checkout.sample
deleted file mode 100755
index af5a0c0..0000000
--- a/susfs4ksu/.git/hooks/push-to-checkout.sample
+++ /dev/null
@@ -1,78 +0,0 @@
-#!/bin/sh
-
-# An example hook script to update a checked-out tree on a git push.
-#
-# This hook is invoked by git-receive-pack(1) when it reacts to git
-# push and updates reference(s) in its repository, and when the push
-# tries to update the branch that is currently checked out and the
-# receive.denyCurrentBranch configuration variable is set to
-# updateInstead.
-#
-# By default, such a push is refused if the working tree and the index
-# of the remote repository has any difference from the currently
-# checked out commit; when both the working tree and the index match
-# the current commit, they are updated to match the newly pushed tip
-# of the branch. This hook is to be used to override the default
-# behaviour; however the code below reimplements the default behaviour
-# as a starting point for convenient modification.
-#
-# The hook receives the commit with which the tip of the current
-# branch is going to be updated:
-commit=$1
-
-# It can exit with a non-zero status to refuse the push (when it does
-# so, it must not modify the index or the working tree).
-die () {
-	echo >&2 "$*"
-	exit 1
-}
-
-# Or it can make any necessary changes to the working tree and to the
-# index to bring them to the desired state when the tip of the current
-# branch is updated to the new commit, and exit with a zero status.
-#
-# For example, the hook can simply run git read-tree -u -m HEAD "$1"
-# in order to emulate git fetch that is run in the reverse direction
-# with git push, as the two-tree form of git read-tree -u -m is
-# essentially the same as git switch or git checkout that switches
-# branches while keeping the local changes in the working tree that do
-# not interfere with the difference between the branches.
-
-# The below is a more-or-less exact translation to shell of the C code
-# for the default behaviour for git's push-to-checkout hook defined in
-# the push_to_deploy() function in builtin/receive-pack.c.
-#
-# Note that the hook will be executed from the repository directory,
-# not from the working tree, so if you want to perform operations on
-# the working tree, you will have to adapt your code accordingly, e.g.
-# by adding "cd .." or using relative paths.
-
-if ! git update-index -q --ignore-submodules --refresh
-then
-	die "Up-to-date check failed"
-fi
-
-if ! git diff-files --quiet --ignore-submodules --
-then
-	die "Working directory has unstaged changes"
-fi
-
-# This is a rough translation of:
-#
-#   head_has_history() ? "HEAD" : EMPTY_TREE_SHA1_HEX
-if git cat-file -e HEAD 2>/dev/null
-then
-	head=HEAD
-else
-	head=$(git hash-object -t tree --stdin </dev/null)
-fi
-
-if ! git diff-index --quiet --cached --ignore-submodules $head --
-then
-	die "Working directory has staged changes"
-fi
-
-if ! git read-tree -u -m "$commit"
-then
-	die "Could not update working tree to new HEAD"
-fi
diff --git a/susfs4ksu/.git/hooks/sendemail-validate.sample b/susfs4ksu/.git/hooks/sendemail-validate.sample
deleted file mode 100755
index 640bcf8..0000000
--- a/susfs4ksu/.git/hooks/sendemail-validate.sample
+++ /dev/null
@@ -1,77 +0,0 @@
-#!/bin/sh
-
-# An example hook script to validate a patch (and/or patch series) before
-# sending it via email.
-#
-# The hook should exit with non-zero status after issuing an appropriate
-# message if it wants to prevent the email(s) from being sent.
-#
-# To enable this hook, rename this file to "sendemail-validate".
-#
-# By default, it will only check that the patch(es) can be applied on top of
-# the default upstream branch without conflicts in a secondary worktree. After
-# validation (successful or not) of the last patch of a series, the worktree
-# will be deleted.
-#
-# The following config variables can be set to change the default remote and
-# remote ref that are used to apply the patches against:
-#
-#   sendemail.validateRemote (default: origin)
-#   sendemail.validateRemoteRef (default: HEAD)
-#
-# Replace the TODO placeholders with appropriate checks according to your
-# needs.
-
-validate_cover_letter () {
-	file="$1"
-	# TODO: Replace with appropriate checks (e.g. spell checking).
-	true
-}
-
-validate_patch () {
-	file="$1"
-	# Ensure that the patch applies without conflicts.
-	git am -3 "$file" || return
-	# TODO: Replace with appropriate checks for this patch
-	# (e.g. checkpatch.pl).
-	true
-}
-
-validate_series () {
-	# TODO: Replace with appropriate checks for the whole series
-	# (e.g. quick build, coding style checks, etc.).
-	true
-}
-
-# main -------------------------------------------------------------------------
-
-if test "$GIT_SENDEMAIL_FILE_COUNTER" = 1
-then
-	remote=$(git config --default origin --get sendemail.validateRemote) &&
-	ref=$(git config --default HEAD --get sendemail.validateRemoteRef) &&
-	worktree=$(mktemp --tmpdir -d sendemail-validate.XXXXXXX) &&
-	git worktree add -fd --checkout "$worktree" "refs/remotes/$remote/$ref" &&
-	git config --replace-all sendemail.validateWorktree "$worktree"
-else
-	worktree=$(git config --get sendemail.validateWorktree)
-fi || {
-	echo "sendemail-validate: error: failed to prepare worktree" >&2
-	exit 1
-}
-
-unset GIT_DIR GIT_WORK_TREE
-cd "$worktree" &&
-
-if grep -q "^diff --git " "$1"
-then
-	validate_patch "$1"
-else
-	validate_cover_letter "$1"
-fi &&
-
-if test "$GIT_SENDEMAIL_FILE_COUNTER" = "$GIT_SENDEMAIL_FILE_TOTAL"
-then
-	git config --unset-all sendemail.validateWorktree &&
-	trap 'git worktree remove -ff "$worktree"' EXIT &&
-	validate_series
-fi
diff --git a/susfs4ksu/.git/hooks/update.sample b/susfs4ksu/.git/hooks/update.sample
deleted file mode 100755
index c4d426b..0000000
--- a/susfs4ksu/.git/hooks/update.sample
+++ /dev/null
@@ -1,128 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to block unannotated tags from entering.
-# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
-#
-# To enable this hook, rename this file to "update".
-#
-# Config
-# ------
-# hooks.allowunannotated
-#   This boolean sets whether unannotated tags will be allowed into the
-#   repository.  By default they won't be.
-# hooks.allowdeletetag
-#   This boolean sets whether deleting tags will be allowed in the
-#   repository.  By default they won't be.
-# hooks.allowmodifytag
-#   This boolean sets whether a tag may be modified after creation. By default
-#   it won't be.
-# hooks.allowdeletebranch
-#   This boolean sets whether deleting branches will be allowed in the
-#   repository.  By default they won't be.
-# hooks.denycreatebranch
-#   This boolean sets whether remotely creating branches will be denied
-#   in the repository.  By default this is allowed.
-#
-
-# --- Command line
-refname="$1"
-oldrev="$2"
-newrev="$3"
-
-# --- Safety check
-if [ -z "$GIT_DIR" ]; then
-	echo "Don't run this script from the command line." >&2
-	echo " (if you want, you could supply GIT_DIR then run" >&2
-	echo "  $0 <ref> <oldrev> <newrev>)" >&2
-	exit 1
-fi
-
-if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
-	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
-	exit 1
-fi
-
-# --- Config
-allowunannotated=$(git config --type=bool hooks.allowunannotated)
-allowdeletebranch=$(git config --type=bool hooks.allowdeletebranch)
-denycreatebranch=$(git config --type=bool hooks.denycreatebranch)
-allowdeletetag=$(git config --type=bool hooks.allowdeletetag)
-allowmodifytag=$(git config --type=bool hooks.allowmodifytag)
-
-# check for no description
-projectdesc=$(sed -e '1q' "$GIT_DIR/description")
-case "$projectdesc" in
-"Unnamed repository"* | "")
-	echo "*** Project description file hasn't been set" >&2
-	exit 1
-	;;
-esac
-
-# --- Check types
-# if $newrev is 0000...0000, it's a commit to delete a ref.
-zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
-if [ "$newrev" = "$zero" ]; then
-	newrev_type=delete
-else
-	newrev_type=$(git cat-file -t $newrev)
-fi
-
-case "$refname","$newrev_type" in
-	refs/tags/*,commit)
-		# un-annotated tag
-		short_refname=${refname##refs/tags/}
-		if [ "$allowunannotated" != "true" ]; then
-			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
-			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
-			exit 1
-		fi
-		;;
-	refs/tags/*,delete)
-		# delete tag
-		if [ "$allowdeletetag" != "true" ]; then
-			echo "*** Deleting a tag is not allowed in this repository" >&2
-			exit 1
-		fi
-		;;
-	refs/tags/*,tag)
-		# annotated tag
-		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
-		then
-			echo "*** Tag '$refname' already exists." >&2
-			echo "*** Modifying a tag is not allowed in this repository." >&2
-			exit 1
-		fi
-		;;
-	refs/heads/*,commit)
-		# branch
-		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
-			echo "*** Creating a branch is not allowed in this repository" >&2
-			exit 1
-		fi
-		;;
-	refs/heads/*,delete)
-		# delete branch
-		if [ "$allowdeletebranch" != "true" ]; then
-			echo "*** Deleting a branch is not allowed in this repository" >&2
-			exit 1
-		fi
-		;;
-	refs/remotes/*,commit)
-		# tracking branch
-		;;
-	refs/remotes/*,delete)
-		# delete tracking branch
-		if [ "$allowdeletebranch" != "true" ]; then
-			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
-			exit 1
-		fi
-		;;
-	*)
-		# Anything else (is there anything else?)
-		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
-		exit 1
-		;;
-esac
-
-# --- Finished
-exit 0
diff --git a/susfs4ksu/.git/index b/susfs4ksu/.git/index
deleted file mode 100644
index 1894a65..0000000
Binary files a/susfs4ksu/.git/index and /dev/null differ
diff --git a/susfs4ksu/.git/info/exclude b/susfs4ksu/.git/info/exclude
deleted file mode 100644
index a5196d1..0000000
--- a/susfs4ksu/.git/info/exclude
+++ /dev/null
@@ -1,6 +0,0 @@
-# git ls-files --others --exclude-from=.git/info/exclude
-# Lines that start with '#' are comments.
-# For a project mostly in C, the following would be a good set of
-# exclude patterns (uncomment them if you want to use them):
-# *.[oa]
-# *~
diff --git a/susfs4ksu/.git/logs/HEAD b/susfs4ksu/.git/logs/HEAD
deleted file mode 100644
index 7253006..0000000
--- a/susfs4ksu/.git/logs/HEAD
+++ /dev/null
@@ -1 +0,0 @@
-0000000000000000000000000000000000000000 76affd70abf61d77feb0a132f61365d6848505df JackA1ltman <cs2dtzq@163.com> 1759504087 +0800	clone: from https://gitlab.com/simonpunk/susfs4ksu.git
diff --git a/susfs4ksu/.git/logs/refs/heads/kernel-5.4 b/susfs4ksu/.git/logs/refs/heads/kernel-5.4
deleted file mode 100644
index 7253006..0000000
--- a/susfs4ksu/.git/logs/refs/heads/kernel-5.4
+++ /dev/null
@@ -1 +0,0 @@
-0000000000000000000000000000000000000000 76affd70abf61d77feb0a132f61365d6848505df JackA1ltman <cs2dtzq@163.com> 1759504087 +0800	clone: from https://gitlab.com/simonpunk/susfs4ksu.git
diff --git a/susfs4ksu/.git/logs/refs/remotes/origin/HEAD b/susfs4ksu/.git/logs/refs/remotes/origin/HEAD
deleted file mode 100644
index a76a21c..0000000
--- a/susfs4ksu/.git/logs/refs/remotes/origin/HEAD
+++ /dev/null
@@ -1 +0,0 @@
-0000000000000000000000000000000000000000 30e66dc3a5c65954de865afd8f44682866887544 JackA1ltman <cs2dtzq@163.com> 1759504087 +0800	clone: from https://gitlab.com/simonpunk/susfs4ksu.git
diff --git a/susfs4ksu/.git/objects/pack/pack-47e8c986b208899174ba626d144e210e0920124b.idx b/susfs4ksu/.git/objects/pack/pack-47e8c986b208899174ba626d144e210e0920124b.idx
deleted file mode 100644
index 6007edd..0000000
Binary files a/susfs4ksu/.git/objects/pack/pack-47e8c986b208899174ba626d144e210e0920124b.idx and /dev/null differ
diff --git a/susfs4ksu/.git/objects/pack/pack-47e8c986b208899174ba626d144e210e0920124b.pack b/susfs4ksu/.git/objects/pack/pack-47e8c986b208899174ba626d144e210e0920124b.pack
deleted file mode 100644
index fe2a5f4..0000000
Binary files a/susfs4ksu/.git/objects/pack/pack-47e8c986b208899174ba626d144e210e0920124b.pack and /dev/null differ
diff --git a/susfs4ksu/.git/objects/pack/pack-47e8c986b208899174ba626d144e210e0920124b.rev b/susfs4ksu/.git/objects/pack/pack-47e8c986b208899174ba626d144e210e0920124b.rev
deleted file mode 100644
index 6bf568f..0000000
Binary files a/susfs4ksu/.git/objects/pack/pack-47e8c986b208899174ba626d144e210e0920124b.rev and /dev/null differ
diff --git a/susfs4ksu/.git/packed-refs b/susfs4ksu/.git/packed-refs
deleted file mode 100644
index ea6eebb..0000000
--- a/susfs4ksu/.git/packed-refs
+++ /dev/null
@@ -1,65 +0,0 @@
-# pack-refs with: peeled fully-peeled sorted 
-ed9a1ee64e1886ee2c0288f1c91e33558465993c refs/remotes/origin/gki-android12-5.10
-e891cdfa40c40e78bb20a3f5acf4d2e8149e3a7d refs/remotes/origin/gki-android13-5.10
-64446fa69ffdb95344874dd0d04bec11caf457a5 refs/remotes/origin/gki-android13-5.15
-24079cda64fb8ae117863176051116f44f05d6e4 refs/remotes/origin/gki-android14-5.15
-bf593ad7804c7892e420a53cd131b8bd65d064af refs/remotes/origin/gki-android14-6.1
-1d41a16950595f86b821e3024c4c313c619cb402 refs/remotes/origin/gki-android15-6.6
-77905b5a071e6f3669e3b1814cea30147c0801da refs/remotes/origin/kernel-4.14
-001e69919c6271f690fd00b17e4c721c9e599152 refs/remotes/origin/kernel-4.19
-41ba0b533b8524a0ba95a5952506a75f17355450 refs/remotes/origin/kernel-4.9
-76affd70abf61d77feb0a132f61365d6848505df refs/remotes/origin/kernel-5.4
-30e66dc3a5c65954de865afd8f44682866887544 refs/remotes/origin/master
-72f00e34cdad8f1a2112b7997a6baeb0de1e0f6f refs/tags/1.0.1
-^224e7ba1f06fd8ed385bb07736d1dba4ba34c4c6
-d786316945fe390285143fd7116ec7d5d5541bd1 refs/tags/1.1.0
-^f9cad8d3975d73f0ba60bc7816d1bb144825f434
-e6001c455357a49a6b147eddc59780bbb20f0b9c refs/tags/1.2.0
-^a54641fb7e4bdce645f2c9c786e16c7e464a5a51
-df4c970513432d5e832aaefc94c84dcc10c03e51 refs/tags/1.2.1
-^4ccc79df3e6984afb8f8ce14b46931eed3373b5b
-e03fd595f79a2d66042c4170de9a1f54765bcf99 refs/tags/1.2.2
-^4864f1c9bd1fde11d819354f530dce5f4fd3a832
-e72f0eba47664c7ca25ab8e0d2b3de2818de2aaf refs/tags/1.2.3
-^72154e3b0bed79d3166cd06e10091c64644a464c
-63a472bd88162ef3dea0567e1eee8867a63d04be refs/tags/1.2.4
-^b87c024a957b89f4d00d47fb2e6d1b62b5d77a10
-5b664d331bfcbf03b7aff3ee290742b6f9f1035e refs/tags/1.2.5
-^afeac10554f155283bb1f879cc14339098354e91
-667d843674f5d458675659272a0649eea2e99490 refs/tags/1.3.0
-^05a77e0f08cc474014e8fb3112c930b73b63835a
-f57efe2c1a65d99e09bfb56a71b8d6c73a440c14 refs/tags/1.3.1
-^d24f8bc0e477b93d5f59d1253d7308e4abae2147
-3888ff3395a7ee096f80bc936ffc8cacbfcd7304 refs/tags/1.3.2
-^c9b79c9896156d20a874501d710d3d52bfd176a6
-7c58e62ba675d2f8e8e9fb5bcdc3178864fca22a refs/tags/1.3.3
-^fbdd9ce0aa335231c5f5b6ccb694137a96771a4d
-d19dfc1be264378893e666ea87c5cc272ccb8d08 refs/tags/1.3.4
-^56ae8caabc349cd2f99b175ad832511dd8a4cea9
-cd51be5eae666cfdab10bcbbbe59139d5c3eb218 refs/tags/1.3.5
-^1be849d6ad9b6d3845b6de4660c59b22fa19dc13
-8153bf38e8e44e08587d10a39ec48187e63e0794 refs/tags/1.3.6
-^f21471957114002158e88e6c4d17c2a57228298d
-52334061348f12559509aa59dcce2beb58ab0ce0 refs/tags/1.3.7
-^9b5e2192a8d7303f85a50d49ebe3e95e57423089
-e6e2866ec8802da9869a5994b02eb26660c376cc refs/tags/1.3.8
-^278b5e83fe8cf5e5924f230f21d3e9f4f66f4cc6
-ce987c3853622f9879433fefcdf4097e34fc489d refs/tags/1.4.2-gki-android12-5.10
-^3f5bd5a0c258b01ec4e01bfd7bcfa18646a0a5f1
-d7c9c5fdc7683afa59e67a6a4c35b57e4aee5b38 refs/tags/1.4.2-gki-android13-5.10
-^c682dd93158556fc63816c254b65b02113bd421f
-6757d9502dca747e5691e447aac29e31daf1bffd refs/tags/1.4.2-gki-android13-5.15
-^cf441b585f3d121149e4073f8dd7fd953bbaa842
-280a561b0619b012be91d8ceee6d857fa1a121f1 refs/tags/1.4.2-gki-android14-5.15
-^335b34546f409dfa0c28502a27b52923519763e0
-aada0316d6384de8171686a4b2b68f6510406c65 refs/tags/1.4.2-kernel-4.14
-^d36aa6aba911a47b9de6b88ba0f621c81581656d
-a71274906909c18578c98387cd6faf6600d137e9 refs/tags/1.4.2-kernel-4.19
-^1a6c90d9a45321bcc5c645720e21a28c36548f83
-deebf151902da7f36705c6fd58d45db13119acd5 refs/tags/1.4.2-kernel-4.9
-^2404aebaeee041c8e0e06ca4636dc87b984c2428
-6295f789abdf8eb99dfa9d8fe44b70319fda876f refs/tags/1.4.2-kernel-5.4
-^36012399ebb8a8de639e65183d2fa65e13a83808
-6a7d4392e2e140c9c804fbf5f74c172e363ee39f refs/tags/1.5.1-gki-android14-5.15
-^baade791bda570ce6f22a373a0794e67a4950285
-d155231e7f83bc9504fc408ee4e7a3612cb09cf6 refs/tags/release-1.0.0
diff --git a/susfs4ksu/.git/refs/heads/kernel-5.4 b/susfs4ksu/.git/refs/heads/kernel-5.4
deleted file mode 100644
index 4f4e1a6..0000000
--- a/susfs4ksu/.git/refs/heads/kernel-5.4
+++ /dev/null
@@ -1 +0,0 @@
-76affd70abf61d77feb0a132f61365d6848505df
diff --git a/susfs4ksu/.git/refs/remotes/origin/HEAD b/susfs4ksu/.git/refs/remotes/origin/HEAD
deleted file mode 100644
index 6efe28f..0000000
--- a/susfs4ksu/.git/refs/remotes/origin/HEAD
+++ /dev/null
@@ -1 +0,0 @@
-ref: refs/remotes/origin/master
diff --git a/susfs4ksu/.gitignore b/susfs4ksu/.gitignore
deleted file mode 100644
index 40170e4..0000000
--- a/susfs4ksu/.gitignore
+++ /dev/null
@@ -1,5 +0,0 @@
-ksu_susfs/obj
-ksu_susfs/libs
-sus_su/obj
-sus_su/libs
-*.zip
diff --git a/susfs4ksu/LICENSE b/susfs4ksu/LICENSE
deleted file mode 100644
index ed80940..0000000
--- a/susfs4ksu/LICENSE
+++ /dev/null
@@ -1,674 +0,0 @@
-                    GNU GENERAL PUBLIC LICENSE
-                       Version 3, 29 June 2007
-
- Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-                            Preamble
-
-  The GNU General Public License is a free, copyleft license for
-software and other kinds of works.
-
-  The licenses for most software and other practical works are designed
-to take away your freedom to share and change the works.  By contrast,
-the GNU General Public License is intended to guarantee your freedom to
-share and change all versions of a program--to make sure it remains free
-software for all its users.  We, the Free Software Foundation, use the
-GNU General Public License for most of our software; it applies also to
-any other work released this way by its authors.  You can apply it to
-your programs, too.
-
-  When we speak of free software, we are referring to freedom, not
-price.  Our General Public Licenses are designed to make sure that you
-have the freedom to distribute copies of free software (and charge for
-them if you wish), that you receive source code or can get it if you
-want it, that you can change the software or use pieces of it in new
-free programs, and that you know you can do these things.
-
-  To protect your rights, we need to prevent others from denying you
-these rights or asking you to surrender the rights.  Therefore, you have
-certain responsibilities if you distribute copies of the software, or if
-you modify it: responsibilities to respect the freedom of others.
-
-  For example, if you distribute copies of such a program, whether
-gratis or for a fee, you must pass on to the recipients the same
-freedoms that you received.  You must make sure that they, too, receive
-or can get the source code.  And you must show them these terms so they
-know their rights.
-
-  Developers that use the GNU GPL protect your rights with two steps:
-(1) assert copyright on the software, and (2) offer you this License
-giving you legal permission to copy, distribute and/or modify it.
-
-  For the developers' and authors' protection, the GPL clearly explains
-that there is no warranty for this free software.  For both users' and
-authors' sake, the GPL requires that modified versions be marked as
-changed, so that their problems will not be attributed erroneously to
-authors of previous versions.
-
-  Some devices are designed to deny users access to install or run
-modified versions of the software inside them, although the manufacturer
-can do so.  This is fundamentally incompatible with the aim of
-protecting users' freedom to change the software.  The systematic
-pattern of such abuse occurs in the area of products for individuals to
-use, which is precisely where it is most unacceptable.  Therefore, we
-have designed this version of the GPL to prohibit the practice for those
-products.  If such problems arise substantially in other domains, we
-stand ready to extend this provision to those domains in future versions
-of the GPL, as needed to protect the freedom of users.
-
-  Finally, every program is threatened constantly by software patents.
-States should not allow patents to restrict development and use of
-software on general-purpose computers, but in those that do, we wish to
-avoid the special danger that patents applied to a free program could
-make it effectively proprietary.  To prevent this, the GPL assures that
-patents cannot be used to render the program non-free.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.
-
-                       TERMS AND CONDITIONS
-
-  0. Definitions.
-
-  "This License" refers to version 3 of the GNU General Public License.
-
-  "Copyright" also means copyright-like laws that apply to other kinds of
-works, such as semiconductor masks.
-
-  "The Program" refers to any copyrightable work licensed under this
-License.  Each licensee is addressed as "you".  "Licensees" and
-"recipients" may be individuals or organizations.
-
-  To "modify" a work means to copy from or adapt all or part of the work
-in a fashion requiring copyright permission, other than the making of an
-exact copy.  The resulting work is called a "modified version" of the
-earlier work or a work "based on" the earlier work.
-
-  A "covered work" means either the unmodified Program or a work based
-on the Program.
-
-  To "propagate" a work means to do anything with it that, without
-permission, would make you directly or secondarily liable for
-infringement under applicable copyright law, except executing it on a
-computer or modifying a private copy.  Propagation includes copying,
-distribution (with or without modification), making available to the
-public, and in some countries other activities as well.
-
-  To "convey" a work means any kind of propagation that enables other
-parties to make or receive copies.  Mere interaction with a user through
-a computer network, with no transfer of a copy, is not conveying.
-
-  An interactive user interface displays "Appropriate Legal Notices"
-to the extent that it includes a convenient and prominently visible
-feature that (1) displays an appropriate copyright notice, and (2)
-tells the user that there is no warranty for the work (except to the
-extent that warranties are provided), that licensees may convey the
-work under this License, and how to view a copy of this License.  If
-the interface presents a list of user commands or options, such as a
-menu, a prominent item in the list meets this criterion.
-
-  1. Source Code.
-
-  The "source code" for a work means the preferred form of the work
-for making modifications to it.  "Object code" means any non-source
-form of a work.
-
-  A "Standard Interface" means an interface that either is an official
-standard defined by a recognized standards body, or, in the case of
-interfaces specified for a particular programming language, one that
-is widely used among developers working in that language.
-
-  The "System Libraries" of an executable work include anything, other
-than the work as a whole, that (a) is included in the normal form of
-packaging a Major Component, but which is not part of that Major
-Component, and (b) serves only to enable use of the work with that
-Major Component, or to implement a Standard Interface for which an
-implementation is available to the public in source code form.  A
-"Major Component", in this context, means a major essential component
-(kernel, window system, and so on) of the specific operating system
-(if any) on which the executable work runs, or a compiler used to
-produce the work, or an object code interpreter used to run it.
-
-  The "Corresponding Source" for a work in object code form means all
-the source code needed to generate, install, and (for an executable
-work) run the object code and to modify the work, including scripts to
-control those activities.  However, it does not include the work's
-System Libraries, or general-purpose tools or generally available free
-programs which are used unmodified in performing those activities but
-which are not part of the work.  For example, Corresponding Source
-includes interface definition files associated with source files for
-the work, and the source code for shared libraries and dynamically
-linked subprograms that the work is specifically designed to require,
-such as by intimate data communication or control flow between those
-subprograms and other parts of the work.
-
-  The Corresponding Source need not include anything that users
-can regenerate automatically from other parts of the Corresponding
-Source.
-
-  The Corresponding Source for a work in source code form is that
-same work.
-
-  2. Basic Permissions.
-
-  All rights granted under this License are granted for the term of
-copyright on the Program, and are irrevocable provided the stated
-conditions are met.  This License explicitly affirms your unlimited
-permission to run the unmodified Program.  The output from running a
-covered work is covered by this License only if the output, given its
-content, constitutes a covered work.  This License acknowledges your
-rights of fair use or other equivalent, as provided by copyright law.
-
-  You may make, run and propagate covered works that you do not
-convey, without conditions so long as your license otherwise remains
-in force.  You may convey covered works to others for the sole purpose
-of having them make modifications exclusively for you, or provide you
-with facilities for running those works, provided that you comply with
-the terms of this License in conveying all material for which you do
-not control copyright.  Those thus making or running the covered works
-for you must do so exclusively on your behalf, under your direction
-and control, on terms that prohibit them from making any copies of
-your copyrighted material outside their relationship with you.
-
-  Conveying under any other circumstances is permitted solely under
-the conditions stated below.  Sublicensing is not allowed; section 10
-makes it unnecessary.
-
-  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
-
-  No covered work shall be deemed part of an effective technological
-measure under any applicable law fulfilling obligations under article
-11 of the WIPO copyright treaty adopted on 20 December 1996, or
-similar laws prohibiting or restricting circumvention of such
-measures.
-
-  When you convey a covered work, you waive any legal power to forbid
-circumvention of technological measures to the extent such circumvention
-is effected by exercising rights under this License with respect to
-the covered work, and you disclaim any intention to limit operation or
-modification of the work as a means of enforcing, against the work's
-users, your or third parties' legal rights to forbid circumvention of
-technological measures.
-
-  4. Conveying Verbatim Copies.
-
-  You may convey verbatim copies of the Program's source code as you
-receive it, in any medium, provided that you conspicuously and
-appropriately publish on each copy an appropriate copyright notice;
-keep intact all notices stating that this License and any
-non-permissive terms added in accord with section 7 apply to the code;
-keep intact all notices of the absence of any warranty; and give all
-recipients a copy of this License along with the Program.
-
-  You may charge any price or no price for each copy that you convey,
-and you may offer support or warranty protection for a fee.
-
-  5. Conveying Modified Source Versions.
-
-  You may convey a work based on the Program, or the modifications to
-produce it from the Program, in the form of source code under the
-terms of section 4, provided that you also meet all of these conditions:
-
-    a) The work must carry prominent notices stating that you modified
-    it, and giving a relevant date.
-
-    b) The work must carry prominent notices stating that it is
-    released under this License and any conditions added under section
-    7.  This requirement modifies the requirement in section 4 to
-    "keep intact all notices".
-
-    c) You must license the entire work, as a whole, under this
-    License to anyone who comes into possession of a copy.  This
-    License will therefore apply, along with any applicable section 7
-    additional terms, to the whole of the work, and all its parts,
-    regardless of how they are packaged.  This License gives no
-    permission to license the work in any other way, but it does not
-    invalidate such permission if you have separately received it.
-
-    d) If the work has interactive user interfaces, each must display
-    Appropriate Legal Notices; however, if the Program has interactive
-    interfaces that do not display Appropriate Legal Notices, your
-    work need not make them do so.
-
-  A compilation of a covered work with other separate and independent
-works, which are not by their nature extensions of the covered work,
-and which are not combined with it such as to form a larger program,
-in or on a volume of a storage or distribution medium, is called an
-"aggregate" if the compilation and its resulting copyright are not
-used to limit the access or legal rights of the compilation's users
-beyond what the individual works permit.  Inclusion of a covered work
-in an aggregate does not cause this License to apply to the other
-parts of the aggregate.
-
-  6. Conveying Non-Source Forms.
-
-  You may convey a covered work in object code form under the terms
-of sections 4 and 5, provided that you also convey the
-machine-readable Corresponding Source under the terms of this License,
-in one of these ways:
-
-    a) Convey the object code in, or embodied in, a physical product
-    (including a physical distribution medium), accompanied by the
-    Corresponding Source fixed on a durable physical medium
-    customarily used for software interchange.
-
-    b) Convey the object code in, or embodied in, a physical product
-    (including a physical distribution medium), accompanied by a
-    written offer, valid for at least three years and valid for as
-    long as you offer spare parts or customer support for that product
-    model, to give anyone who possesses the object code either (1) a
-    copy of the Corresponding Source for all the software in the
-    product that is covered by this License, on a durable physical
-    medium customarily used for software interchange, for a price no
-    more than your reasonable cost of physically performing this
-    conveying of source, or (2) access to copy the
-    Corresponding Source from a network server at no charge.
-
-    c) Convey individual copies of the object code with a copy of the
-    written offer to provide the Corresponding Source.  This
-    alternative is allowed only occasionally and noncommercially, and
-    only if you received the object code with such an offer, in accord
-    with subsection 6b.
-
-    d) Convey the object code by offering access from a designated
-    place (gratis or for a charge), and offer equivalent access to the
-    Corresponding Source in the same way through the same place at no
-    further charge.  You need not require recipients to copy the
-    Corresponding Source along with the object code.  If the place to
-    copy the object code is a network server, the Corresponding Source
-    may be on a different server (operated by you or a third party)
-    that supports equivalent copying facilities, provided you maintain
-    clear directions next to the object code saying where to find the
-    Corresponding Source.  Regardless of what server hosts the
-    Corresponding Source, you remain obligated to ensure that it is
-    available for as long as needed to satisfy these requirements.
-
-    e) Convey the object code using peer-to-peer transmission, provided
-    you inform other peers where the object code and Corresponding
-    Source of the work are being offered to the general public at no
-    charge under subsection 6d.
-
-  A separable portion of the object code, whose source code is excluded
-from the Corresponding Source as a System Library, need not be
-included in conveying the object code work.
-
-  A "User Product" is either (1) a "consumer product", which means any
-tangible personal property which is normally used for personal, family,
-or household purposes, or (2) anything designed or sold for incorporation
-into a dwelling.  In determining whether a product is a consumer product,
-doubtful cases shall be resolved in favor of coverage.  For a particular
-product received by a particular user, "normally used" refers to a
-typical or common use of that class of product, regardless of the status
-of the particular user or of the way in which the particular user
-actually uses, or expects or is expected to use, the product.  A product
-is a consumer product regardless of whether the product has substantial
-commercial, industrial or non-consumer uses, unless such uses represent
-the only significant mode of use of the product.
-
-  "Installation Information" for a User Product means any methods,
-procedures, authorization keys, or other information required to install
-and execute modified versions of a covered work in that User Product from
-a modified version of its Corresponding Source.  The information must
-suffice to ensure that the continued functioning of the modified object
-code is in no case prevented or interfered with solely because
-modification has been made.
-
-  If you convey an object code work under this section in, or with, or
-specifically for use in, a User Product, and the conveying occurs as
-part of a transaction in which the right of possession and use of the
-User Product is transferred to the recipient in perpetuity or for a
-fixed term (regardless of how the transaction is characterized), the
-Corresponding Source conveyed under this section must be accompanied
-by the Installation Information.  But this requirement does not apply
-if neither you nor any third party retains the ability to install
-modified object code on the User Product (for example, the work has
-been installed in ROM).
-
-  The requirement to provide Installation Information does not include a
-requirement to continue to provide support service, warranty, or updates
-for a work that has been modified or installed by the recipient, or for
-the User Product in which it has been modified or installed.  Access to a
-network may be denied when the modification itself materially and
-adversely affects the operation of the network or violates the rules and
-protocols for communication across the network.
-
-  Corresponding Source conveyed, and Installation Information provided,
-in accord with this section must be in a format that is publicly
-documented (and with an implementation available to the public in
-source code form), and must require no special password or key for
-unpacking, reading or copying.
-
-  7. Additional Terms.
-
-  "Additional permissions" are terms that supplement the terms of this
-License by making exceptions from one or more of its conditions.
-Additional permissions that are applicable to the entire Program shall
-be treated as though they were included in this License, to the extent
-that they are valid under applicable law.  If additional permissions
-apply only to part of the Program, that part may be used separately
-under those permissions, but the entire Program remains governed by
-this License without regard to the additional permissions.
-
-  When you convey a copy of a covered work, you may at your option
-remove any additional permissions from that copy, or from any part of
-it.  (Additional permissions may be written to require their own
-removal in certain cases when you modify the work.)  You may place
-additional permissions on material, added by you to a covered work,
-for which you have or can give appropriate copyright permission.
-
-  Notwithstanding any other provision of this License, for material you
-add to a covered work, you may (if authorized by the copyright holders of
-that material) supplement the terms of this License with terms:
-
-    a) Disclaiming warranty or limiting liability differently from the
-    terms of sections 15 and 16 of this License; or
-
-    b) Requiring preservation of specified reasonable legal notices or
-    author attributions in that material or in the Appropriate Legal
-    Notices displayed by works containing it; or
-
-    c) Prohibiting misrepresentation of the origin of that material, or
-    requiring that modified versions of such material be marked in
-    reasonable ways as different from the original version; or
-
-    d) Limiting the use for publicity purposes of names of licensors or
-    authors of the material; or
-
-    e) Declining to grant rights under trademark law for use of some
-    trade names, trademarks, or service marks; or
-
-    f) Requiring indemnification of licensors and authors of that
-    material by anyone who conveys the material (or modified versions of
-    it) with contractual assumptions of liability to the recipient, for
-    any liability that these contractual assumptions directly impose on
-    those licensors and authors.
-
-  All other non-permissive additional terms are considered "further
-restrictions" within the meaning of section 10.  If the Program as you
-received it, or any part of it, contains a notice stating that it is
-governed by this License along with a term that is a further
-restriction, you may remove that term.  If a license document contains
-a further restriction but permits relicensing or conveying under this
-License, you may add to a covered work material governed by the terms
-of that license document, provided that the further restriction does
-not survive such relicensing or conveying.
-
-  If you add terms to a covered work in accord with this section, you
-must place, in the relevant source files, a statement of the
-additional terms that apply to those files, or a notice indicating
-where to find the applicable terms.
-
-  Additional terms, permissive or non-permissive, may be stated in the
-form of a separately written license, or stated as exceptions;
-the above requirements apply either way.
-
-  8. Termination.
-
-  You may not propagate or modify a covered work except as expressly
-provided under this License.  Any attempt otherwise to propagate or
-modify it is void, and will automatically terminate your rights under
-this License (including any patent licenses granted under the third
-paragraph of section 11).
-
-  However, if you cease all violation of this License, then your
-license from a particular copyright holder is reinstated (a)
-provisionally, unless and until the copyright holder explicitly and
-finally terminates your license, and (b) permanently, if the copyright
-holder fails to notify you of the violation by some reasonable means
-prior to 60 days after the cessation.
-
-  Moreover, your license from a particular copyright holder is
-reinstated permanently if the copyright holder notifies you of the
-violation by some reasonable means, this is the first time you have
-received notice of violation of this License (for any work) from that
-copyright holder, and you cure the violation prior to 30 days after
-your receipt of the notice.
-
-  Termination of your rights under this section does not terminate the
-licenses of parties who have received copies or rights from you under
-this License.  If your rights have been terminated and not permanently
-reinstated, you do not qualify to receive new licenses for the same
-material under section 10.
-
-  9. Acceptance Not Required for Having Copies.
-
-  You are not required to accept this License in order to receive or
-run a copy of the Program.  Ancillary propagation of a covered work
-occurring solely as a consequence of using peer-to-peer transmission
-to receive a copy likewise does not require acceptance.  However,
-nothing other than this License grants you permission to propagate or
-modify any covered work.  These actions infringe copyright if you do
-not accept this License.  Therefore, by modifying or propagating a
-covered work, you indicate your acceptance of this License to do so.
-
-  10. Automatic Licensing of Downstream Recipients.
-
-  Each time you convey a covered work, the recipient automatically
-receives a license from the original licensors, to run, modify and
-propagate that work, subject to this License.  You are not responsible
-for enforcing compliance by third parties with this License.
-
-  An "entity transaction" is a transaction transferring control of an
-organization, or substantially all assets of one, or subdividing an
-organization, or merging organizations.  If propagation of a covered
-work results from an entity transaction, each party to that
-transaction who receives a copy of the work also receives whatever
-licenses to the work the party's predecessor in interest had or could
-give under the previous paragraph, plus a right to possession of the
-Corresponding Source of the work from the predecessor in interest, if
-the predecessor has it or can get it with reasonable efforts.
-
-  You may not impose any further restrictions on the exercise of the
-rights granted or affirmed under this License.  For example, you may
-not impose a license fee, royalty, or other charge for exercise of
-rights granted under this License, and you may not initiate litigation
-(including a cross-claim or counterclaim in a lawsuit) alleging that
-any patent claim is infringed by making, using, selling, offering for
-sale, or importing the Program or any portion of it.
-
-  11. Patents.
-
-  A "contributor" is a copyright holder who authorizes use under this
-License of the Program or a work on which the Program is based.  The
-work thus licensed is called the contributor's "contributor version".
-
-  A contributor's "essential patent claims" are all patent claims
-owned or controlled by the contributor, whether already acquired or
-hereafter acquired, that would be infringed by some manner, permitted
-by this License, of making, using, or selling its contributor version,
-but do not include claims that would be infringed only as a
-consequence of further modification of the contributor version.  For
-purposes of this definition, "control" includes the right to grant
-patent sublicenses in a manner consistent with the requirements of
-this License.
-
-  Each contributor grants you a non-exclusive, worldwide, royalty-free
-patent license under the contributor's essential patent claims, to
-make, use, sell, offer for sale, import and otherwise run, modify and
-propagate the contents of its contributor version.
-
-  In the following three paragraphs, a "patent license" is any express
-agreement or commitment, however denominated, not to enforce a patent
-(such as an express permission to practice a patent or covenant not to
-sue for patent infringement).  To "grant" such a patent license to a
-party means to make such an agreement or commitment not to enforce a
-patent against the party.
-
-  If you convey a covered work, knowingly relying on a patent license,
-and the Corresponding Source of the work is not available for anyone
-to copy, free of charge and under the terms of this License, through a
-publicly available network server or other readily accessible means,
-then you must either (1) cause the Corresponding Source to be so
-available, or (2) arrange to deprive yourself of the benefit of the
-patent license for this particular work, or (3) arrange, in a manner
-consistent with the requirements of this License, to extend the patent
-license to downstream recipients.  "Knowingly relying" means you have
-actual knowledge that, but for the patent license, your conveying the
-covered work in a country, or your recipient's use of the covered work
-in a country, would infringe one or more identifiable patents in that
-country that you have reason to believe are valid.
-
-  If, pursuant to or in connection with a single transaction or
-arrangement, you convey, or propagate by procuring conveyance of, a
-covered work, and grant a patent license to some of the parties
-receiving the covered work authorizing them to use, propagate, modify
-or convey a specific copy of the covered work, then the patent license
-you grant is automatically extended to all recipients of the covered
-work and works based on it.
-
-  A patent license is "discriminatory" if it does not include within
-the scope of its coverage, prohibits the exercise of, or is
-conditioned on the non-exercise of one or more of the rights that are
-specifically granted under this License.  You may not convey a covered
-work if you are a party to an arrangement with a third party that is
-in the business of distributing software, under which you make payment
-to the third party based on the extent of your activity of conveying
-the work, and under which the third party grants, to any of the
-parties who would receive the covered work from you, a discriminatory
-patent license (a) in connection with copies of the covered work
-conveyed by you (or copies made from those copies), or (b) primarily
-for and in connection with specific products or compilations that
-contain the covered work, unless you entered into that arrangement,
-or that patent license was granted, prior to 28 March 2007.
-
-  Nothing in this License shall be construed as excluding or limiting
-any implied license or other defenses to infringement that may
-otherwise be available to you under applicable patent law.
-
-  12. No Surrender of Others' Freedom.
-
-  If conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot convey a
-covered work so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you may
-not convey it at all.  For example, if you agree to terms that obligate you
-to collect a royalty for further conveying from those to whom you convey
-the Program, the only way you could satisfy both those terms and this
-License would be to refrain entirely from conveying the Program.
-
-  13. Use with the GNU Affero General Public License.
-
-  Notwithstanding any other provision of this License, you have
-permission to link or combine any covered work with a work licensed
-under version 3 of the GNU Affero General Public License into a single
-combined work, and to convey the resulting work.  The terms of this
-License will continue to apply to the part which is the covered work,
-but the special requirements of the GNU Affero General Public License,
-section 13, concerning interaction through a network will apply to the
-combination as such.
-
-  14. Revised Versions of this License.
-
-  The Free Software Foundation may publish revised and/or new versions of
-the GNU General Public License from time to time.  Such new versions will
-be similar in spirit to the present version, but may differ in detail to
-address new problems or concerns.
-
-  Each version is given a distinguishing version number.  If the
-Program specifies that a certain numbered version of the GNU General
-Public License "or any later version" applies to it, you have the
-option of following the terms and conditions either of that numbered
-version or of any later version published by the Free Software
-Foundation.  If the Program does not specify a version number of the
-GNU General Public License, you may choose any version ever published
-by the Free Software Foundation.
-
-  If the Program specifies that a proxy can decide which future
-versions of the GNU General Public License can be used, that proxy's
-public statement of acceptance of a version permanently authorizes you
-to choose that version for the Program.
-
-  Later license versions may give you additional or different
-permissions.  However, no additional obligations are imposed on any
-author or copyright holder as a result of your choosing to follow a
-later version.
-
-  15. Disclaimer of Warranty.
-
-  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
-APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
-HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
-OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
-THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
-IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
-ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
-
-  16. Limitation of Liability.
-
-  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
-THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
-GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
-USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
-DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
-PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
-EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
-SUCH DAMAGES.
-
-  17. Interpretation of Sections 15 and 16.
-
-  If the disclaimer of warranty and limitation of liability provided
-above cannot be given local legal effect according to their terms,
-reviewing courts shall apply local law that most closely approximates
-an absolute waiver of all civil liability in connection with the
-Program, unless a warranty or assumption of liability accompanies a
-copy of the Program in return for a fee.
-
-                     END OF TERMS AND CONDITIONS
-
-            How to Apply These Terms to Your New Programs
-
-  If you develop a new program, and you want it to be of the greatest
-possible use to the public, the best way to achieve this is to make it
-free software which everyone can redistribute and change under these terms.
-
-  To do so, attach the following notices to the program.  It is safest
-to attach them to the start of each source file to most effectively
-state the exclusion of warranty; and each file should have at least
-the "copyright" line and a pointer to where the full notice is found.
-
-    <one line to give the program's name and a brief idea of what it does.>
-    Copyright (C) 2024  simonpunk
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-
-Also add information on how to contact you by electronic and paper mail.
-
-  If the program does terminal interaction, make it output a short
-notice like this when it starts in an interactive mode:
-
-    <program>  Copyright (C) 2024  simonpunk
-    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
-    This is free software, and you are welcome to redistribute it
-    under certain conditions; type `show c' for details.
-
-The hypothetical commands `show w' and `show c' should show the appropriate
-parts of the General Public License.  Of course, your program's commands
-might be different; for a GUI interface, you would use an "about box".
-
-  You should also get your employer (if you work as a programmer) or school,
-if any, to sign a "copyright disclaimer" for the program, if necessary.
-For more information on this, and how to apply and follow the GNU GPL, see
-<https://www.gnu.org/licenses/>.
-
-  The GNU General Public License does not permit incorporating your program
-into proprietary programs.  If your program is a subroutine library, you
-may consider it more useful to permit linking proprietary applications with
-the library.  If this is what you want to do, use the GNU Lesser General
-Public License instead of this License.  But first, please read
-<https://www.gnu.org/licenses/why-not-lgpl.html>.
diff --git a/susfs4ksu/README.md b/susfs4ksu/README.md
deleted file mode 100644
index 87e3f5f..0000000
--- a/susfs4ksu/README.md
+++ /dev/null
@@ -1,103 +0,0 @@
-## Introduction ##
-- An addon root hiding kernel patches and userspace module for KernelSU.
-
-- The userspace tool `ksu_susfs`, as well as the ksu module, require a susfs patched kernel to work.
-
-# Warning #
-- This is only experimental code, that said it can harm your system or cause performance hit, **YOU ARE !! W A R N E D !!** already
-
-## Compatibility ##
-- The susfs kernel patches may differ for different kernel version or even on the same kernel version, you may need to create your own patches for your kernel.
-
-## Patch Instruction (For GKI Kernel only and building from official google artifacts) ##
-**- Prerequisite -**
-1. All susfs patches are based on the **original official KernelSU (the one from weishu)** with **latest release tag**, so you should clone his repo with **latest release tag** for a better patching result.
-2. SUSFS now supports AUTO_ADD_ features for Magick Mount KernelSU as long as you have `KSU_SUSFS_HAS_MAGIC_MOUNT` feature enabled.
-
-**- Apply SUSFS patches -**
-1. Make sure you follow the offical KSU guild here to clone and build the kernel with KSU: `https://kernelsu.org/guide/how-to-build.html`, the kernel root directory should be `$KERNEL_REPO/common`, you should run script to clone KSU in `$KERNEL_REPO`
-2. Clone the SUSFS repo with a tag or release version, as they are more stable in general.
-2. Run `cp ./kernel_patches/KernelSU/10_enable_susfs_for_ksu.patch $KERNEL_REPO/KernelSU/`
-3. Run `cp ./kernel_patches/50_add_susfs_in_kernel-<kernel_version>.patch $KERNEL_REPO/common/`
-4. Run `cp ./kernel_patches/fs/* $KERNEL_REPO/common/fs/`
-5. Run `cp ./kernel_patches/include/linux/* $KERNEL_REPO/common/include/linux/`
-6. Run `cd $KERNEL_REPO/KernelSU` and then `patch -p1 < 10_enable_susfs_for_ksu.patch`
-7. Run `cd $KERNEL_REPO/common` and then `patch -p1 < 50_add_susfs_in_kernel.patch`, **if there are failed patches, you may try to patch them manually by yourself.**
-8. If you want to make your kernel support other KSU manager variant, you can add its own hash size and hash in `ksu_is_manager_apk()` function in `KernelSU/kernel/apk_sign.c`
-9. Make sure again to have `CONFIG_KSU` and `CONFIG_KSU_SUSFS` enabled before building the kernel, some other SUSFS feature may be disabled by default, you may enable/disable them via `menuconfig`, `kernel defconfig`, or change the `default [y|n]` option under each `config KSU_SUSFS_` option in `$KernelSU_repo/kernel/Kconfig` if you build with a new defconfig every time.
-10. If your kernel already has the **KSU non-kprobe hook patches** applied, then you have to **`DISABLE`** the `CONFIG_KSU_SUSFS_SUS_SU` option.
-11. If your KernelSU manager is using magic mount, then you should enable **`KSU_SUSFS_HAS_MAGIC_MOUNT`** option so that mounts can be handled by AUTO_ADD_ features.
-12. For `gki kernel android14` or above, if you are building from google artifacts, it is necessary to delete the file `$KERNEL_REPO/common/android/abi_gki_protected_exports_aarch64` and `$KERNEL_REPO/common/android/abi_gki_protected_exports_x86_64`, otherwise some modules like WiFi will not work. Or you can just remove those files whenever they exist in your kernel repo.
-13. If you want to flash the fresh built gki boot.img, then before you build the kernel, first you need to fix or hardcode the `local spl_date` in function `build_gki_boot_images()` in `$KERNEL_REPO/build/kernel/build_utils.sh` to match the current boot security patch level of your phone. Or you can just use magiskboot to unpack and repack the built kernel for your stock boot.img.
-14. Build and flash the kernel.
-15. For some compilor error, please refer to the section **[Known Compilor Issues]** below.
-16. For other building tips, please refer to the section **[Other Building Tips]** below.
-
-## Build ksu_susfs userspace tool ##
-1. Run `./build_ksu_susfs_tool.sh` to build the userspace tool `ksu_susfs`, and the arm64 and arm binary will be copied to `ksu_module_susfs/tools/` as well.
-2. Now you can also push the compiled `ksu_susfs` tool to `/data/adb/ksu/bin/` so that you can run it directly in adb root shell or termux root shell, as well as in your own ksu modules.
-
-## Build sus_su userspace tool (Deprecated) ##
-**--Important Notes--**
-- sus_su userspace tool is now deprecated, as newer xiaomi devices are found to have a root detection service running which is named "mrmd" and it is spawned by init process, and since sus_su mounted by overlayfs can't be umounted for process spawned by init process, so it will get detected unless there is a better umount scheme for init spawned process.
-
-**--Instruction for 1st mode (Deprecated)--**
-- sus_su userspace tool is an executable aimed to get a root shell by sending a request to a susfs fifo driver, this is exclusive for **"kprobe hook enabled KSU"** only, **DO NOT** use it if your KernelSU has kprobe **disabled**.
-- Only apps with root access granted by ksu manager are allow to run 'su'.
-- For best compatibility, sus_su requires overlayfs to allow all other 3rd party apps to execute 'su' to get root shell.
-- See `service.sh` in module templete for more details.
-
-1. Run `./build_sus_su_tool.sh` to build the sus_su executable, the arm64 and arm binary will be copied to `ksu_module_susfs/tools/`.
-2. Uncomment the line `#enable_sus_su` in service.sh to enable sus_su
-3. Run `./build_ksu_module.sh` to build the module and flash again.
-
-**--Instruction for 2nd mode--**
-- Just run `ksu_susfs sus_su 2` to disable core kprobe hooks and enable inline hooks for su.
-
-
-## Build susfs4ksu module ##
-- The ksu module here is just a demo to show how to use it.
-- It will also copy the `ksu_susfs` and `sus_su` tool to `/data/adb/ksu/bin/` as well when installing the module.
-
-1. ksu_susfs tool can be run in any stage scripts, post-fs-data.sh, services.sh, boot-completed.sh according to your own need.
-2. Run `./build_ksu_module.sh` to build the susfs KSU module.
-
-## Usage of ksu_susfs and supported features ##
-- Run `ksu_susfs` in root shell for detailed usages.
-- See `$KernelSU_repo/kernel/Kconfig` for supported features after applying the susfs patches.
-
-## Other Building Tips ##
-- To only remove the `-dirty` string from kernel release string, open file `$KERNEL_ROOT/scripts/setlocalversion`, then look for all the lines that containing `printf '%s' -dirty`, and replace it with `printf '%s' ''`
-- Alternatively, If you want to directly hardcode the whole kernel release string, then open file `$KERNEL_ROOT/scripts/setlocalversion`, look for the last line `echo "$res"`, and for example, replace it with `echo "-android13-01-gb123456789012-ab12345678"`
-- To hardcode your kernel version string, open `$KERNEL_ROOT/scripts/mkcompile_h`, and look for line `UTS_VERSION="$(echo $UTS_VERSION $CONFIG_FLAGS $TIMESTAMP | cut -b -$UTS_LEN)"`, then for example, replace it with `UTS_VERSION="#1 SMP PREEMPT Mon Jan 1 18:00:00 UTC 2024"`
-- To hardcode your kernel version string which can be seen from /proc/version, open `$KERNEL_ROOT/scripts/mkcompile_h`, then search for variable name `LINUX_COMPILE_BY` and `LINUX_COMPILE_HOST`, then for example, append `LINUX_COMPILE_BY=build-user` and `LINUX_COMPILE_HOST=build-host` after line `UTS_VERSION="$(echo $UTS_VERSION $CONFIG_FLAGS $TIMESTAMP | cut -b -$UTS_LEN)"`
-- To spoof the `/proc/config.gz` with the stock config, 
-
-   1. Make sure you are on the stock ROM and using stock kernel.
-   2. Use adb shell or root shell to pull your stock `/proc/config.gz` from your device to PC.
-   3. Decompress it using `gunzip` or whatever tools, then copy it to `$KERNEL_ROOT/arch/arm64/configs/stock_defconfig`
-   4. Open file `$KERNEL_ROOT/kernel/Makefile`.
-   5. Look for line `$(obj)/config_data: $(KCONFIG_CONFIG) FORCE`, and replace it with `$(obj)/config_data: arch/arm64/configs/stock_defconfig FORCE`
-
-## Known Compiler Issues ##
-   1. error: no member named 'android_kabi_reservedx' in 'struct yyyyyyyy'
-
-      - Because normally the memeber `u64 android_kabi_reservedx;` doesn't exist in all structs with all kernel version below 4.19, and sometimes it is not guaranteed existed with kernel version >= 4.19 and <= 5.4, and even with GKI kernel, like some of the custom kernels has all of them disabled. So at this point if the susfs patches didn't have them patched for you, then what you need to do is to manually append the member to the end of the corresponding struct definition, it should be `u64 android_kabi_reservedx;` with the last `x` starting from `1`, like `u64 android_kabi_reserved1;`, `u64 android_kabi_reserved2;` and so on. You may also refer to patch from other branches like `kernel-4.14`, `kernel-4.9` of this repo for extra `diff` of the missing kabi members.
-
-## Other Known Issues ##
-- Some of the File Explorer Apps cannot display a files/directory properly when a specific sub path of '/sdcard' or '/storage/emulated/0' is added to sus_path
-    1. Make sure the file explorer app has root allowed by KSU manager, because sus_path is only effective on no root allowed process uid.
-    2. It is strongly NOT recommended adding sub path of '/sdcard' or '/storage/emulated/0' to sus_path, because file explorer app is likely using android API to retrieve the list of files/directory, which means the calling uid will be changed to other system media provider app such as the google provider to execute the file lookup operation, and makes sus_path think that it is not a root allowed process uid so as to prevent them from showing up, unless the app obtains the root access first then use root privilege to list the files/directories without using android API.
-
-## Credits ##
-- KernelSU: https://github.com/tiann/KernelSU
-- KernelSU fork: https://github.com/5ec1cff/KernelSU
-- @Kartatz: for ideas and original commit from https://github.com/Dominium-Apum/kernel_xiaomi_chime/pull/1/commits/74f8d4ecacd343432bb8137b7e7fbe3fd9fef189
-
-## Telegram ##
-- @simonpunk
-
-
-## Buy me a coffee ##
-- PayPal: kingjeffkimo@yahoo.com.tw
-- BTC: bc1qgkwvsfln02463zpjf7z6tds8xnpeykggtgk4kw
diff --git a/susfs4ksu/build_ksu_module.sh b/susfs4ksu/build_ksu_module.sh
deleted file mode 100755
index 23bfd12..0000000
--- a/susfs4ksu/build_ksu_module.sh
+++ /dev/null
@@ -1,8 +0,0 @@
-#!/bin/bash
-
-OUT_FILE=ksu_module_susfs.zip
-OLD_CWD=$(pwd)
-
-cd ksu_module_susfs && zip -r9 ../${OUT_FILE} * -x ${OUT_FILE}
-
-cd ${OLD_CWD}
diff --git a/susfs4ksu/build_ksu_susfs_tool.sh b/susfs4ksu/build_ksu_susfs_tool.sh
deleted file mode 100755
index 7b4a192..0000000
--- a/susfs4ksu/build_ksu_susfs_tool.sh
+++ /dev/null
@@ -1,19 +0,0 @@
-#!/bin/bash
-
-OLD_CWD=$(pwd)
-
-if ! ndk-build -s -v &>/dev/null; then
-    echo "[-] Have you added the root directory of ndk-build to your PATH envoironment variable?"
-    exit 1
-fi
-
-set -x
-
-cd ./ksu_susfs
-rm -rf libs obj 2>/dev/null
-ndk-build
-cp libs/arm64-v8a/ksu_susfs ../ksu_module_susfs/tools/ksu_susfs_arm64
-cd ${OLD_CWD}
-
-
-
diff --git a/susfs4ksu/build_sus_su_tool.sh b/susfs4ksu/build_sus_su_tool.sh
deleted file mode 100755
index 319d6fa..0000000
--- a/susfs4ksu/build_sus_su_tool.sh
+++ /dev/null
@@ -1,20 +0,0 @@
-#!/bin/bash
-
-cat <<EOF >/dev/null
-OLD_CWD=$(pwd)
-
-if ! ndk-build -s -v &>/dev/null; then
-    echo "[-] Have you added the root directory of ndk-build to your PATH envoironment variable?"
-    exit 1
-fi
-
-set -x
-
-cd ./sus_su
-rm -rf libs obj 2>/dev/null
-ndk-build
-cp libs/arm64-v8a/sus_su ../ksu_module_susfs/tools/sus_su_arm64
-cd ${OLD_CWD}
-
-
-EOF
diff --git a/susfs4ksu/kernel_patches/fs/sus_su.c b/susfs4ksu/kernel_patches/fs/sus_su.c
deleted file mode 100644
index d140468..0000000
--- a/susfs4ksu/kernel_patches/fs/sus_su.c
+++ /dev/null
@@ -1,140 +0,0 @@
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/fs.h>
-#include <linux/uaccess.h>
-#include <linux/cdev.h>
-#include <linux/random.h>
-#include <linux/cred.h>
-#include <linux/sus_su.h>
-
-#ifdef CONFIG_KSU_SUSFS_ENABLE_LOG
-extern bool susfs_is_log_enabled __read_mostly;
-#define SUSFS_LOGI(fmt, ...) if (susfs_is_log_enabled) pr_info("susfs_sus_su:[%u][%u][%s] " fmt, current_uid().val, current->pid, __func__, ##__VA_ARGS__)
-#define SUSFS_LOGE(fmt, ...) if (susfs_is_log_enabled) pr_err("susfs_sus_su:[%u][%u][%s]" fmt, current_uid().val, current->pid, __func__, ##__VA_ARGS__)
-#else
-#define SUSFS_LOGI(fmt, ...)
-#define SUSFS_LOGE(fmt, ...)
-#endif
-
-#define FIFO_SIZE 1024
-#define MAX_DRV_NAME 255
-
-static int cur_maj_dev_num = -1;
-static char fifo_buffer[FIFO_SIZE];
-static struct cdev sus_su_cdev;
-static const char *sus_su_token = "!@#$SU_IS_SUS$#@!-pRE6W9BKXrJr1hEKyvDq0CvWziVKbatT8yzq06fhtrEGky2tVS7Q2QTjhtMfVMGV";
-static char rand_drv_path[MAX_DRV_NAME+1] = "/dev/";
-static bool is_sus_su_enabled_before = false;
-
-extern bool susfs_is_allow_su(void);
-extern void ksu_escape_to_root(void);
-
-static void gen_rand_drv_name(char *buffer, size_t min_length, size_t max_length) {
-    const char *symbols = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-+@#:=";
-    size_t symbols_length = strlen(symbols);
-    size_t length, i;
-    unsigned int rand_value;
-
-    // Determine the random length of the string
-    get_random_bytes(&rand_value, sizeof(rand_value));
-    length = min_length + (rand_value % (max_length - min_length + 1));
-
-    for (i = 0; i < length; ++i) {
-        get_random_bytes(&rand_value, sizeof(rand_value));
-        buffer[i] = symbols[rand_value % symbols_length];
-    }
-    buffer[length] = '\0'; // Null-terminate the string
-}
-
-static int fifo_open(struct inode *inode, struct file *file) {
-    return 0;
-}
-
-static int fifo_release(struct inode *inode, struct file *file) {
-    return 0;
-}
-
-static ssize_t fifo_read(struct file *file, char __user *buf, size_t len, loff_t *offset) {
-    return 0;
-}
-
-static ssize_t fifo_write(struct file *file, const char __user *buf, size_t len, loff_t *offset) {
-    int sus_su_token_len = strlen(sus_su_token);
-
-    if (!susfs_is_allow_su()) {
-        SUSFS_LOGE("root is not allowed for uid: '%d', pid: '%d'\n", current_uid().val, current->pid);
-        return 0;
-    }
-
-    if (copy_from_user(fifo_buffer, buf, sus_su_token_len+1)) {
-        SUSFS_LOGE("copy_from_user() failed, uid: '%d', pid: '%d'\n", current_uid().val, current->pid);
-        return 0;
-    }
-
-    if (!memcmp(fifo_buffer, sus_su_token, sus_su_token_len+1)) {
-        SUSFS_LOGI("granting root access for uid: '%d', pid: '%d'\n", current_uid().val, current->pid);
-        ksu_escape_to_root();
-    } else {
-        SUSFS_LOGI("wrong token! deny root access for uid: '%d', pid: '%d'\n", current_uid().val, current->pid);
-    }
-    memset(fifo_buffer, 0, FIFO_SIZE);
-    return 0;
-}
-
-static struct file_operations fops = {
-    .owner = THIS_MODULE,
-    .open = fifo_open,
-    .release = fifo_release,
-    .read = fifo_read,
-    .write = fifo_write,
-};
-
-int sus_su_fifo_init(int *maj_dev_num, char *drv_path) {
-    if (cur_maj_dev_num > 0) {
-        SUSFS_LOGE("'%s' is already registered\n", rand_drv_path);
-        return -1;
-    }
-
-    // generate a random driver name if it is executed for the first time
-    if (!is_sus_su_enabled_before) {
-        // min length 192, max length 248, just make sure max length doesn't exceeds 255
-        gen_rand_drv_name(rand_drv_path+5, 192, 248);
-    }
-
-    cur_maj_dev_num = register_chrdev(0, rand_drv_path+5, &fops);
-    if (cur_maj_dev_num < 0) {
-        SUSFS_LOGE("Failed to register character device\n");
-        return -1;
-    }
-
-    cdev_init(&sus_su_cdev, &fops);
-    if (cdev_add(&sus_su_cdev, MKDEV(cur_maj_dev_num, 0), 1) < 0) {
-        unregister_chrdev(cur_maj_dev_num, rand_drv_path+5);
-        SUSFS_LOGE("Failed to add cdev\n");
-        return -1;
-    }
-
-    strncpy(drv_path, rand_drv_path, strlen(rand_drv_path));
-    *maj_dev_num = cur_maj_dev_num;
-    SUSFS_LOGI("'%s' registered with major device number %d\n", rand_drv_path, cur_maj_dev_num);
-    
-    if (!is_sus_su_enabled_before)
-        is_sus_su_enabled_before = true;
-
-    return 0;
-}
-
-int sus_su_fifo_exit(int *maj_dev_num, char *drv_path) {
-    if (cur_maj_dev_num < 0) {
-        SUSFS_LOGE("'%s' was already unregistered before\n", rand_drv_path);
-        return 0;
-    }
-
-    cdev_del(&sus_su_cdev);
-    unregister_chrdev(cur_maj_dev_num, rand_drv_path+5);
-    cur_maj_dev_num = -1;
-    *maj_dev_num = cur_maj_dev_num;
-    strncpy(drv_path, rand_drv_path, strlen(rand_drv_path));
-    SUSFS_LOGI("'%s' unregistered\n", rand_drv_path);
-    return 0;
-}
diff --git a/susfs4ksu/kernel_patches/fs/susfs.c b/susfs4ksu/kernel_patches/fs/susfs.c
deleted file mode 100644
index 2d95768..0000000
--- a/susfs4ksu/kernel_patches/fs/susfs.c
+++ /dev/null
@@ -1,916 +0,0 @@
-#include <linux/version.h>
-#include <linux/cred.h>
-#include <linux/fs.h>
-#include <linux/slab.h>
-#include <linux/seq_file.h>
-#include <linux/printk.h>
-#include <linux/namei.h>
-#include <linux/list.h>
-#include <linux/init_task.h>
-#include <linux/spinlock.h>
-#include <linux/stat.h>
-#include <linux/uaccess.h>
-#include <linux/version.h>
-#include <linux/fdtable.h>
-#include <linux/statfs.h>
-#include <linux/susfs.h>
-#include "mount.h"
-
-static spinlock_t susfs_spin_lock;
-
-extern bool susfs_is_current_ksu_domain(void);
-#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
-extern void ksu_try_umount(const char *mnt, bool check_mnt, int flags, uid_t uid);
-#endif
-
-#ifdef CONFIG_KSU_SUSFS_ENABLE_LOG
-bool susfs_is_log_enabled __read_mostly = true;
-#define SUSFS_LOGI(fmt, ...) if (susfs_is_log_enabled) pr_info("susfs:[%u][%d][%s] " fmt, current_uid().val, current->pid, __func__, ##__VA_ARGS__)
-#define SUSFS_LOGE(fmt, ...) if (susfs_is_log_enabled) pr_err("susfs:[%u][%d][%s]" fmt, current_uid().val, current->pid, __func__, ##__VA_ARGS__)
-#else
-#define SUSFS_LOGI(fmt, ...) 
-#define SUSFS_LOGE(fmt, ...) 
-#endif
-
-/* sus_path */
-#ifdef CONFIG_KSU_SUSFS_SUS_PATH
-static DEFINE_HASHTABLE(SUS_PATH_HLIST, 10);
-static int susfs_update_sus_path_inode(char *target_pathname) {
-	struct path p;
-	struct inode *inode = NULL;
-	const char *dev_type;
-
-	if (kern_path(target_pathname, LOOKUP_FOLLOW, &p)) {
-		SUSFS_LOGE("Failed opening file '%s'\n", target_pathname);
-		return 1;
-	}
-
-	// - We don't allow paths of which filesystem type is "tmpfs" or "fuse".
-	//   For tmpfs, because its starting inode->i_ino will begin with 1 again,
-	//   so it will cause wrong comparison in function susfs_sus_ino_for_filldir64()
-	//   For fuse, which is almost storage related, sus_path should not handle any paths of
-	//   which filesystem is "fuse" as well, since app can write to "fuse" and lookup files via
-	//   like binder / system API (you can see the uid is changed to 1000)/
-	// - so sus_path should be applied only on read-only filesystem like "erofs" or "f2fs", but not "tmpfs" or "fuse",
-	//   people may rely on HMA for /data isolation instead.
-	dev_type = p.mnt->mnt_sb->s_type->name;
-	if (!strcmp(dev_type, "tmpfs") ||
-		!strcmp(dev_type, "fuse")) {
-		SUSFS_LOGE("target_pathname: '%s' cannot be added since its filesystem type is '%s'\n",
-						target_pathname, dev_type);
-		path_put(&p);
-		return 1;
-	}
-
-	inode = d_inode(p.dentry);
-	if (!inode) {
-		SUSFS_LOGE("inode is NULL\n");
-		path_put(&p);
-		return 1;
-	}
-
-	if (!(inode->i_state & INODE_STATE_SUS_PATH)) {
-		spin_lock(&inode->i_lock);
-		inode->i_state |= INODE_STATE_SUS_PATH;
-		spin_unlock(&inode->i_lock);
-	}
-	path_put(&p);
-	return 0;
-}
-
-int susfs_add_sus_path(struct st_susfs_sus_path* __user user_info) {
-	struct st_susfs_sus_path info;
-	struct st_susfs_sus_path_hlist *new_entry, *tmp_entry;
-	struct hlist_node *tmp_node;
-	int bkt;
-	bool update_hlist = false;
-
-	if (copy_from_user(&info, user_info, sizeof(info))) {
-		SUSFS_LOGE("failed copying from userspace\n");
-		return 1;
-	}
-
-	spin_lock(&susfs_spin_lock);
-	hash_for_each_safe(SUS_PATH_HLIST, bkt, tmp_node, tmp_entry, node) {
-	if (!strcmp(tmp_entry->target_pathname, info.target_pathname)) {
-			hash_del(&tmp_entry->node);
-			kfree(tmp_entry);
-			update_hlist = true;
-			break;
-		}
-	}
-	spin_unlock(&susfs_spin_lock);
-
-	new_entry = kmalloc(sizeof(struct st_susfs_sus_path_hlist), GFP_KERNEL);
-	if (!new_entry) {
-		SUSFS_LOGE("no enough memory\n");
-		return 1;
-	}
-
-	new_entry->target_ino = info.target_ino;
-	strncpy(new_entry->target_pathname, info.target_pathname, SUSFS_MAX_LEN_PATHNAME-1);
-	if (susfs_update_sus_path_inode(new_entry->target_pathname)) {
-		kfree(new_entry);
-		return 1;
-	}
-	spin_lock(&susfs_spin_lock);
-	hash_add(SUS_PATH_HLIST, &new_entry->node, info.target_ino);
-	if (update_hlist) {
-		SUSFS_LOGI("target_ino: '%lu', target_pathname: '%s' is successfully updated to SUS_PATH_HLIST\n",
-				new_entry->target_ino, new_entry->target_pathname);	
-	} else {
-		SUSFS_LOGI("target_ino: '%lu', target_pathname: '%s' is successfully added to SUS_PATH_HLIST\n",
-				new_entry->target_ino, new_entry->target_pathname);
-	}
-	spin_unlock(&susfs_spin_lock);
-	return 0;
-}
-
-int susfs_sus_ino_for_filldir64(unsigned long ino) {
-	struct st_susfs_sus_path_hlist *entry;
-
-	hash_for_each_possible(SUS_PATH_HLIST, entry, node, ino) {
-		if (entry->target_ino == ino)
-			return 1;
-	}
-	return 0;
-}
-#endif // #ifdef CONFIG_KSU_SUSFS_SUS_PATH
-
-/* sus_mount */
-#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
-static LIST_HEAD(LH_SUS_MOUNT);
-static void susfs_update_sus_mount_inode(char *target_pathname) {
-	struct mount *mnt = NULL;
-	struct path p;
-	struct inode *inode = NULL;
-	int err = 0;
-
-	err = kern_path(target_pathname, LOOKUP_FOLLOW, &p);
-	if (err) {
-		SUSFS_LOGE("Failed opening file '%s'\n", target_pathname);
-		return;
-	}
-
-	/* It is important to check if the mount has a legit peer group id, if so we cannot add them to sus_mount,
-	 * since there are chances that the mount is a legit mountpoint, and it can be misued by other susfs functions in future.
-	 * And by doing this it won't affect the sus_mount check as other susfs functions check by mnt->mnt_id
-	 * instead of INODE_STATE_SUS_MOUNT.
-	 */
-	mnt = real_mount(p.mnt);
-	if (mnt->mnt_group_id > 0 && // 0 means no peer group
-		mnt->mnt_group_id < DEFAULT_SUS_MNT_GROUP_ID) {
-		SUSFS_LOGE("skip setting SUS_MOUNT inode state for path '%s' since its source mount has a legit peer group id\n", target_pathname);
-		return;
-	}
-
-	inode = d_inode(p.dentry);
-	if (!inode) {
-		path_put(&p);
-		SUSFS_LOGE("inode is NULL\n");
-		return;
-	}
-
-	if (!(inode->i_state & INODE_STATE_SUS_MOUNT)) {
-		spin_lock(&inode->i_lock);
-		inode->i_state |= INODE_STATE_SUS_MOUNT;
-		spin_unlock(&inode->i_lock);
-	}
-	path_put(&p);
-}
-
-int susfs_add_sus_mount(struct st_susfs_sus_mount* __user user_info) {
-	struct st_susfs_sus_mount_list *cursor = NULL, *temp = NULL;
-	struct st_susfs_sus_mount_list *new_list = NULL;
-	struct st_susfs_sus_mount info;
-
-	if (copy_from_user(&info, user_info, sizeof(info))) {
-		SUSFS_LOGE("failed copying from userspace\n");
-		return 1;
-	}
-
-#if defined(__ARCH_WANT_STAT64) || defined(__ARCH_WANT_COMPAT_STAT64)
-#ifdef CONFIG_MIPS
-	info.target_dev = new_decode_dev(info.target_dev);
-#else
-	info.target_dev = huge_decode_dev(info.target_dev);
-#endif /* CONFIG_MIPS */
-#else
-	info.target_dev = old_decode_dev(info.target_dev);
-#endif /* defined(__ARCH_WANT_STAT64) || defined(__ARCH_WANT_COMPAT_STAT64) */
-
-	list_for_each_entry_safe(cursor, temp, &LH_SUS_MOUNT, list) {
-		if (unlikely(!strcmp(cursor->info.target_pathname, info.target_pathname))) {
-			spin_lock(&susfs_spin_lock);
-			memcpy(&cursor->info, &info, sizeof(info));
-			susfs_update_sus_mount_inode(cursor->info.target_pathname);
-			SUSFS_LOGI("target_pathname: '%s', target_dev: '%lu', is successfully updated to LH_SUS_MOUNT\n",
-						cursor->info.target_pathname, cursor->info.target_dev);
-			spin_unlock(&susfs_spin_lock);
-			return 0;
-		}
-	}
-
-	new_list = kmalloc(sizeof(struct st_susfs_sus_mount_list), GFP_KERNEL);
-	if (!new_list) {
-		SUSFS_LOGE("no enough memory\n");
-		return 1;
-	}
-
-	memcpy(&new_list->info, &info, sizeof(info));
-	susfs_update_sus_mount_inode(new_list->info.target_pathname);
-
-	INIT_LIST_HEAD(&new_list->list);
-	spin_lock(&susfs_spin_lock);
-	list_add_tail(&new_list->list, &LH_SUS_MOUNT);
-	SUSFS_LOGI("target_pathname: '%s', target_dev: '%lu', is successfully added to LH_SUS_MOUNT\n",
-				new_list->info.target_pathname, new_list->info.target_dev);
-	spin_unlock(&susfs_spin_lock);
-	return 0;
-}
-
-#ifdef CONFIG_KSU_SUSFS_AUTO_ADD_SUS_BIND_MOUNT
-int susfs_auto_add_sus_bind_mount(const char *pathname, struct path *path_target) {
-	struct mount *mnt;
-	struct inode *inode;
-
-	mnt = real_mount(path_target->mnt);
-	if (mnt->mnt_group_id > 0 && // 0 means no peer group
-		mnt->mnt_group_id < DEFAULT_SUS_MNT_GROUP_ID) {
-		SUSFS_LOGE("skip setting SUS_MOUNT inode state for path '%s' since its source mount has a legit peer group id\n", pathname);
-		// return 0 here as we still want it to be added to try_umount list
-		return 0;
-	}
-	inode = path_target->dentry->d_inode;
-	if (!inode) return 1;
-	if (!(inode->i_state & INODE_STATE_SUS_MOUNT)) {
-		spin_lock(&inode->i_lock);
-		inode->i_state |= INODE_STATE_SUS_MOUNT;
-		spin_unlock(&inode->i_lock);
-		SUSFS_LOGI("set SUS_MOUNT inode state for source bind mount path '%s'\n", pathname);
-	}
-	return 0;
-}
-#endif // #ifdef CONFIG_KSU_SUSFS_AUTO_ADD_SUS_BIND_MOUNT
-
-#ifdef CONFIG_KSU_SUSFS_AUTO_ADD_SUS_KSU_DEFAULT_MOUNT
-void susfs_auto_add_sus_ksu_default_mount(const char __user *to_pathname) {
-	char *pathname = NULL;
-	struct path path;
-	struct inode *inode;
-
-	pathname = kmalloc(SUSFS_MAX_LEN_PATHNAME, GFP_KERNEL);
-	if (!pathname) {
-		SUSFS_LOGE("no enough memory\n");
-		return;
-	}
-	// Here we need to re-retrieve the struct path as we want the new struct path, not the old one
-	if (strncpy_from_user(pathname, to_pathname, SUSFS_MAX_LEN_PATHNAME-1) < 0) {
-		SUSFS_LOGE("strncpy_from_user()\n");
-		goto out_free_pathname;
-		return;
-	}
-	if ((!strncmp(pathname, "/data/adb/modules", 17) ||
-		 !strncmp(pathname, "/debug_ramdisk", 14) ||
-		 !strncmp(pathname, "/system", 7) ||
-		 !strncmp(pathname, "/system_ext", 11) ||
-		 !strncmp(pathname, "/vendor", 7) ||
-		 !strncmp(pathname, "/product", 8) ||
-		 !strncmp(pathname, "/odm", 4)) &&
-		 !kern_path(pathname, LOOKUP_FOLLOW, &path)) {
-		goto set_inode_sus_mount;
-	}
-	goto out_free_pathname;
-set_inode_sus_mount:
-	inode = path.dentry->d_inode;
-	if (!inode) {
-		goto out_path_put;
-		return;
-	}
-	if (!(inode->i_state & INODE_STATE_SUS_MOUNT)) {
-		spin_lock(&inode->i_lock);
-		inode->i_state |= INODE_STATE_SUS_MOUNT;
-		spin_unlock(&inode->i_lock);
-		SUSFS_LOGI("set SUS_MOUNT inode state for default KSU mount path '%s'\n", pathname);
-	}
-out_path_put:
-	path_put(&path);
-out_free_pathname:
-	kfree(pathname);
-}
-#endif // #ifdef CONFIG_KSU_SUSFS_AUTO_ADD_SUS_KSU_DEFAULT_MOUNT
-#endif // #ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
-
-/* sus_kstat */
-#ifdef CONFIG_KSU_SUSFS_SUS_KSTAT
-static DEFINE_HASHTABLE(SUS_KSTAT_HLIST, 10);
-static int susfs_update_sus_kstat_inode(char *target_pathname) {
-	struct path p;
-	struct inode *inode = NULL;
-	int err = 0;
-
-	err = kern_path(target_pathname, LOOKUP_FOLLOW, &p);
-	if (err) {
-		SUSFS_LOGE("Failed opening file '%s'\n", target_pathname);
-		return 1;
-	}
-
-	// We don't allow path of which filesystem type is "tmpfs", because its inode->i_ino is starting from 1 again,
-	// which will cause wrong comparison in function susfs_sus_ino_for_filldir64()
-	if (strcmp(p.mnt->mnt_sb->s_type->name, "tmpfs") == 0) {
-		SUSFS_LOGE("target_pathname: '%s' cannot be added since its filesystem is 'tmpfs'\n", target_pathname);
-		path_put(&p);
-		return 1;
-	}
-
-	inode = d_inode(p.dentry);
-	if (!inode) {
-		path_put(&p);
-		SUSFS_LOGE("inode is NULL\n");
-		return 1;
-	}
-
-	if (!(inode->i_state & INODE_STATE_SUS_KSTAT)) {
-		spin_lock(&inode->i_lock);
-		inode->i_state |= INODE_STATE_SUS_KSTAT;
-		spin_unlock(&inode->i_lock);
-	}
-	path_put(&p);
-	return 0;
-}
-
-int susfs_add_sus_kstat(struct st_susfs_sus_kstat* __user user_info) {
-	struct st_susfs_sus_kstat info;
-	struct st_susfs_sus_kstat_hlist *new_entry, *tmp_entry;
-	struct hlist_node *tmp_node;
-	int bkt;
-	bool update_hlist = false;
-
-	if (copy_from_user(&info, user_info, sizeof(info))) {
-		SUSFS_LOGE("failed copying from userspace\n");
-		return 1;
-	}
-
-	if (strlen(info.target_pathname) == 0) {
-		SUSFS_LOGE("target_pathname is an empty string\n");
-		return 1;
-	}
-
-	spin_lock(&susfs_spin_lock);
-	hash_for_each_safe(SUS_KSTAT_HLIST, bkt, tmp_node, tmp_entry, node) {
-		if (!strcmp(tmp_entry->info.target_pathname, info.target_pathname)) {
-			hash_del(&tmp_entry->node);
-			kfree(tmp_entry);
-			update_hlist = true;
-			break;
-		}
-	}
-	spin_unlock(&susfs_spin_lock);
-
-	new_entry = kmalloc(sizeof(struct st_susfs_sus_kstat_hlist), GFP_KERNEL);
-	if (!new_entry) {
-		SUSFS_LOGE("no enough memory\n");
-		return 1;
-	}
-
-#if defined(__ARCH_WANT_STAT64) || defined(__ARCH_WANT_COMPAT_STAT64)
-#ifdef CONFIG_MIPS
-	info.spoofed_dev = new_decode_dev(info.spoofed_dev);
-#else
-	info.spoofed_dev = huge_decode_dev(info.spoofed_dev);
-#endif /* CONFIG_MIPS */
-#else
-	info.spoofed_dev = old_decode_dev(info.spoofed_dev);
-#endif /* defined(__ARCH_WANT_STAT64) || defined(__ARCH_WANT_COMPAT_STAT64) */
-
-	new_entry->target_ino = info.target_ino;
-	memcpy(&new_entry->info, &info, sizeof(info));
-
-	if (susfs_update_sus_kstat_inode(new_entry->info.target_pathname)) {
-		kfree(new_entry);
-		return 1;
-	}
-
-	spin_lock(&susfs_spin_lock);
-	hash_add(SUS_KSTAT_HLIST, &new_entry->node, info.target_ino);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0)
-	if (update_hlist) {
-		SUSFS_LOGI("is_statically: '%d', target_ino: '%lu', target_pathname: '%s', spoofed_ino: '%lu', spoofed_dev: '%lu', spoofed_nlink: '%u', spoofed_size: '%llu', spoofed_atime_tv_sec: '%ld', spoofed_mtime_tv_sec: '%ld', spoofed_ctime_tv_sec: '%ld', spoofed_atime_tv_nsec: '%ld', spoofed_mtime_tv_nsec: '%ld', spoofed_ctime_tv_nsec: '%ld', spoofed_blksize: '%lu', spoofed_blocks: '%llu', is successfully added to SUS_KSTAT_HLIST\n",
-				new_entry->info.is_statically, new_entry->info.target_ino, new_entry->info.target_pathname,
-				new_entry->info.spoofed_ino, new_entry->info.spoofed_dev,
-				new_entry->info.spoofed_nlink, new_entry->info.spoofed_size,
-				new_entry->info.spoofed_atime_tv_sec, new_entry->info.spoofed_mtime_tv_sec, new_entry->info.spoofed_ctime_tv_sec,
-				new_entry->info.spoofed_atime_tv_nsec, new_entry->info.spoofed_mtime_tv_nsec, new_entry->info.spoofed_ctime_tv_nsec,
-				new_entry->info.spoofed_blksize, new_entry->info.spoofed_blocks);
-	} else {
-		SUSFS_LOGI("is_statically: '%d', target_ino: '%lu', target_pathname: '%s', spoofed_ino: '%lu', spoofed_dev: '%lu', spoofed_nlink: '%u', spoofed_size: '%llu', spoofed_atime_tv_sec: '%ld', spoofed_mtime_tv_sec: '%ld', spoofed_ctime_tv_sec: '%ld', spoofed_atime_tv_nsec: '%ld', spoofed_mtime_tv_nsec: '%ld', spoofed_ctime_tv_nsec: '%ld', spoofed_blksize: '%lu', spoofed_blocks: '%llu', is successfully updated to SUS_KSTAT_HLIST\n",
-				new_entry->info.is_statically, new_entry->info.target_ino, new_entry->info.target_pathname,
-				new_entry->info.spoofed_ino, new_entry->info.spoofed_dev,
-				new_entry->info.spoofed_nlink, new_entry->info.spoofed_size,
-				new_entry->info.spoofed_atime_tv_sec, new_entry->info.spoofed_mtime_tv_sec, new_entry->info.spoofed_ctime_tv_sec,
-				new_entry->info.spoofed_atime_tv_nsec, new_entry->info.spoofed_mtime_tv_nsec, new_entry->info.spoofed_ctime_tv_nsec,
-				new_entry->info.spoofed_blksize, new_entry->info.spoofed_blocks);
-	}
-#else
-	if (update_hlist) {
-		SUSFS_LOGI("is_statically: '%d', target_ino: '%lu', target_pathname: '%s', spoofed_ino: '%lu', spoofed_dev: '%lu', spoofed_nlink: '%u', spoofed_size: '%u', spoofed_atime_tv_sec: '%ld', spoofed_mtime_tv_sec: '%ld', spoofed_ctime_tv_sec: '%ld', spoofed_atime_tv_nsec: '%ld', spoofed_mtime_tv_nsec: '%ld', spoofed_ctime_tv_nsec: '%ld', spoofed_blksize: '%lu', spoofed_blocks: '%llu', is successfully added to SUS_KSTAT_HLIST\n",
-				new_entry->info.is_statically, new_entry->info.target_ino, new_entry->info.target_pathname,
-				new_entry->info.spoofed_ino, new_entry->info.spoofed_dev,
-				new_entry->info.spoofed_nlink, new_entry->info.spoofed_size,
-				new_entry->info.spoofed_atime_tv_sec, new_entry->info.spoofed_mtime_tv_sec, new_entry->info.spoofed_ctime_tv_sec,
-				new_entry->info.spoofed_atime_tv_nsec, new_entry->info.spoofed_mtime_tv_nsec, new_entry->info.spoofed_ctime_tv_nsec,
-				new_entry->info.spoofed_blksize, new_entry->info.spoofed_blocks);
-	} else {
-		SUSFS_LOGI("is_statically: '%d', target_ino: '%lu', target_pathname: '%s', spoofed_ino: '%lu', spoofed_dev: '%lu', spoofed_nlink: '%u', spoofed_size: '%u', spoofed_atime_tv_sec: '%ld', spoofed_mtime_tv_sec: '%ld', spoofed_ctime_tv_sec: '%ld', spoofed_atime_tv_nsec: '%ld', spoofed_mtime_tv_nsec: '%ld', spoofed_ctime_tv_nsec: '%ld', spoofed_blksize: '%lu', spoofed_blocks: '%llu', is successfully updated to SUS_KSTAT_HLIST\n",
-				new_entry->info.is_statically, new_entry->info.target_ino, new_entry->info.target_pathname,
-				new_entry->info.spoofed_ino, new_entry->info.spoofed_dev,
-				new_entry->info.spoofed_nlink, new_entry->info.spoofed_size,
-				new_entry->info.spoofed_atime_tv_sec, new_entry->info.spoofed_mtime_tv_sec, new_entry->info.spoofed_ctime_tv_sec,
-				new_entry->info.spoofed_atime_tv_nsec, new_entry->info.spoofed_mtime_tv_nsec, new_entry->info.spoofed_ctime_tv_nsec,
-				new_entry->info.spoofed_blksize, new_entry->info.spoofed_blocks);
-	}
-#endif
-	spin_unlock(&susfs_spin_lock);
-	return 0;
-}
-
-int susfs_update_sus_kstat(struct st_susfs_sus_kstat* __user user_info) {
-	struct st_susfs_sus_kstat info;
-	struct st_susfs_sus_kstat_hlist *new_entry, *tmp_entry;
-	struct hlist_node *tmp_node;
-	int bkt;
-	int err = 0;
-
-	if (copy_from_user(&info, user_info, sizeof(info))) {
-		SUSFS_LOGE("failed copying from userspace\n");
-		return 1;
-	}
-
-	spin_lock(&susfs_spin_lock);
-	hash_for_each_safe(SUS_KSTAT_HLIST, bkt, tmp_node, tmp_entry, node) {
-		if (!strcmp(tmp_entry->info.target_pathname, info.target_pathname)) {
-			if (susfs_update_sus_kstat_inode(tmp_entry->info.target_pathname)) {
-				err = 1;
-				goto out_spin_unlock;
-			}
-			new_entry = kmalloc(sizeof(struct st_susfs_sus_kstat_hlist), GFP_KERNEL);
-			if (!new_entry) {
-				SUSFS_LOGE("no enough memory\n");
-				err = 1;
-				goto out_spin_unlock;
-			}
-			memcpy(&new_entry->info, &tmp_entry->info, sizeof(tmp_entry->info));
-			SUSFS_LOGI("updating target_ino from '%lu' to '%lu' for pathname: '%s' in SUS_KSTAT_HLIST\n",
-							new_entry->info.target_ino, info.target_ino, info.target_pathname);
-			new_entry->target_ino = info.target_ino;
-			new_entry->info.target_ino = info.target_ino;
-			if (info.spoofed_size > 0) {
-				SUSFS_LOGI("updating spoofed_size from '%lld' to '%lld' for pathname: '%s' in SUS_KSTAT_HLIST\n",
-								new_entry->info.spoofed_size, info.spoofed_size, info.target_pathname);
-				new_entry->info.spoofed_size = info.spoofed_size;
-			}
-			if (info.spoofed_blocks > 0) {
-				SUSFS_LOGI("updating spoofed_blocks from '%llu' to '%llu' for pathname: '%s' in SUS_KSTAT_HLIST\n",
-								new_entry->info.spoofed_blocks, info.spoofed_blocks, info.target_pathname);
-				new_entry->info.spoofed_blocks = info.spoofed_blocks;
-			}
-			hash_del(&tmp_entry->node);
-			kfree(tmp_entry);
-			hash_add(SUS_KSTAT_HLIST, &new_entry->node, info.target_ino);
-			goto out_spin_unlock;
-		}
-	}
-out_spin_unlock:
-	spin_unlock(&susfs_spin_lock);
-	return err;
-}
-
-void susfs_sus_ino_for_generic_fillattr(unsigned long ino, struct kstat *stat) {
-	struct st_susfs_sus_kstat_hlist *entry;
-
-	hash_for_each_possible(SUS_KSTAT_HLIST, entry, node, ino) {
-		if (entry->target_ino == ino) {
-			stat->dev = entry->info.spoofed_dev;
-			stat->ino = entry->info.spoofed_ino;
-			stat->nlink = entry->info.spoofed_nlink;
-			stat->size = entry->info.spoofed_size;
-			stat->atime.tv_sec = entry->info.spoofed_atime_tv_sec;
-			stat->atime.tv_nsec = entry->info.spoofed_atime_tv_nsec;
-			stat->mtime.tv_sec = entry->info.spoofed_mtime_tv_sec;
-			stat->mtime.tv_nsec = entry->info.spoofed_mtime_tv_nsec;
-			stat->ctime.tv_sec = entry->info.spoofed_ctime_tv_sec;
-			stat->ctime.tv_nsec = entry->info.spoofed_ctime_tv_nsec;
-			stat->blocks = entry->info.spoofed_blocks;
-			stat->blksize = entry->info.spoofed_blksize;
-			return;
-		}
-	}
-}
-
-void susfs_sus_ino_for_show_map_vma(unsigned long ino, dev_t *out_dev, unsigned long *out_ino) {
-	struct st_susfs_sus_kstat_hlist *entry;
-
-	hash_for_each_possible(SUS_KSTAT_HLIST, entry, node, ino) {
-		if (entry->target_ino == ino) {
-			*out_dev = entry->info.spoofed_dev;
-			*out_ino = entry->info.spoofed_ino;
-			return;
-		}
-	}
-}
-#endif // #ifdef CONFIG_KSU_SUSFS_SUS_KSTAT
-
-/* try_umount */
-#ifdef CONFIG_KSU_SUSFS_TRY_UMOUNT
-static LIST_HEAD(LH_TRY_UMOUNT_PATH);
-int susfs_add_try_umount(struct st_susfs_try_umount* __user user_info) {
-	struct st_susfs_try_umount_list *cursor = NULL, *temp = NULL;
-	struct st_susfs_try_umount_list *new_list = NULL;
-	struct st_susfs_try_umount info;
-
-	if (copy_from_user(&info, user_info, sizeof(info))) {
-		SUSFS_LOGE("failed copying from userspace\n");
-		return 1;
-	}
-
-	list_for_each_entry_safe(cursor, temp, &LH_TRY_UMOUNT_PATH, list) {
-		if (unlikely(!strcmp(info.target_pathname, cursor->info.target_pathname))) {
-			SUSFS_LOGE("target_pathname: '%s' is already created in LH_TRY_UMOUNT_PATH\n", info.target_pathname);
-			return 1;
-		}
-	}
-
-	new_list = kmalloc(sizeof(struct st_susfs_try_umount_list), GFP_KERNEL);
-	if (!new_list) {
-		SUSFS_LOGE("no enough memory\n");
-		return 1;
-	}
-
-	memcpy(&new_list->info, &info, sizeof(info));
-
-	INIT_LIST_HEAD(&new_list->list);
-	spin_lock(&susfs_spin_lock);
-	list_add_tail(&new_list->list, &LH_TRY_UMOUNT_PATH);
-	spin_unlock(&susfs_spin_lock);
-	SUSFS_LOGI("target_pathname: '%s', mnt_mode: %d, is successfully added to LH_TRY_UMOUNT_PATH\n", new_list->info.target_pathname, new_list->info.mnt_mode);
-	return 0;
-}
-
-void susfs_try_umount(uid_t target_uid) {
-	struct st_susfs_try_umount_list *cursor = NULL;
-
-	// We should umount in reversed order
-	list_for_each_entry_reverse(cursor, &LH_TRY_UMOUNT_PATH, list) {
-		if (cursor->info.mnt_mode == TRY_UMOUNT_DEFAULT) {
-			ksu_try_umount(cursor->info.target_pathname, false, 0, target_uid);
-		} else if (cursor->info.mnt_mode == TRY_UMOUNT_DETACH) {
-			ksu_try_umount(cursor->info.target_pathname, false, MNT_DETACH, target_uid);
-		} else {
-			SUSFS_LOGE("failed umounting '%s' for uid: %d, mnt_mode '%d' not supported\n",
-							cursor->info.target_pathname, target_uid, cursor->info.mnt_mode);
-		}
-	}
-}
-
-#ifdef CONFIG_KSU_SUSFS_AUTO_ADD_TRY_UMOUNT_FOR_BIND_MOUNT
-void susfs_auto_add_try_umount_for_bind_mount(struct path *path) {
-	struct st_susfs_try_umount_list *cursor = NULL, *temp = NULL;
-	struct st_susfs_try_umount_list *new_list = NULL;
-	char *pathname = NULL, *dpath = NULL;
-#ifdef CONFIG_KSU_SUSFS_HAS_MAGIC_MOUNT
-	bool is_magic_mount_path = false;
-#endif
-
-#ifdef CONFIG_KSU_SUSFS_SUS_KSTAT
-	if (path->dentry->d_inode->i_state & INODE_STATE_SUS_KSTAT) {
-		SUSFS_LOGI("skip adding path to try_umount list as its inode is flagged INODE_STATE_SUS_KSTAT already\n");
-		return;
-	}
-#endif
-
-	pathname = kmalloc(PAGE_SIZE, GFP_KERNEL);
-	if (!pathname) {
-		SUSFS_LOGE("no enough memory\n");
-		return;
-	}
-
-	dpath = d_path(path, pathname, PAGE_SIZE);
-	if (!dpath) {
-		SUSFS_LOGE("dpath is NULL\n");
-		goto out_free_pathname;
-	}
-
-#ifdef CONFIG_KSU_SUSFS_HAS_MAGIC_MOUNT
-	if (strstr(dpath, MAGIC_MOUNT_WORKDIR)) {
-		is_magic_mount_path = true;
-	}
-#endif
-
-	list_for_each_entry_safe(cursor, temp, &LH_TRY_UMOUNT_PATH, list) {
-#ifdef CONFIG_KSU_SUSFS_HAS_MAGIC_MOUNT
-		if (is_magic_mount_path && strstr(dpath, cursor->info.target_pathname)) {
-			goto out_free_pathname;
-		}
-#endif
-		if (unlikely(!strcmp(dpath, cursor->info.target_pathname))) {
-			SUSFS_LOGE("target_pathname: '%s', ino: %lu, is already created in LH_TRY_UMOUNT_PATH\n",
-							dpath, path->dentry->d_inode->i_ino);
-			goto out_free_pathname;
-		}
-	}
-
-	new_list = kmalloc(sizeof(struct st_susfs_try_umount_list), GFP_KERNEL);
-	if (!new_list) {
-		SUSFS_LOGE("no enough memory\n");
-		goto out_free_pathname;
-	}
-
-#ifdef CONFIG_KSU_SUSFS_HAS_MAGIC_MOUNT
-	if (is_magic_mount_path) {
-		strncpy(new_list->info.target_pathname, dpath + strlen(MAGIC_MOUNT_WORKDIR), SUSFS_MAX_LEN_PATHNAME-1);
-		goto out_add_to_list;
-	}
-#endif
-	strncpy(new_list->info.target_pathname, dpath, SUSFS_MAX_LEN_PATHNAME-1);
-
-#ifdef CONFIG_KSU_SUSFS_HAS_MAGIC_MOUNT
-out_add_to_list:
-#endif
-
-	new_list->info.mnt_mode = TRY_UMOUNT_DETACH;
-
-	INIT_LIST_HEAD(&new_list->list);
-	spin_lock(&susfs_spin_lock);
-	list_add_tail(&new_list->list, &LH_TRY_UMOUNT_PATH);
-	spin_unlock(&susfs_spin_lock);
-	SUSFS_LOGI("target_pathname: '%s', ino: %lu, mnt_mode: %d, is successfully added to LH_TRY_UMOUNT_PATH\n",
-					new_list->info.target_pathname, path->dentry->d_inode->i_ino, new_list->info.mnt_mode);
-out_free_pathname:
-	kfree(pathname);
-}
-#endif // #ifdef CONFIG_KSU_SUSFS_AUTO_ADD_TRY_UMOUNT_FOR_BIND_MOUNT
-#endif // #ifdef CONFIG_KSU_SUSFS_TRY_UMOUNT
-
-/* spoof_uname */
-#ifdef CONFIG_KSU_SUSFS_SPOOF_UNAME
-static spinlock_t susfs_uname_spin_lock;
-static struct st_susfs_uname my_uname;
-static void susfs_my_uname_init(void) {
-	memset(&my_uname, 0, sizeof(my_uname));
-}
-
-int susfs_set_uname(struct st_susfs_uname* __user user_info) {
-	struct st_susfs_uname info;
-
-	if (copy_from_user(&info, user_info, sizeof(struct st_susfs_uname))) {
-		SUSFS_LOGE("failed copying from userspace.\n");
-		return 1;
-	}
-
-	spin_lock(&susfs_uname_spin_lock);
-	if (!strcmp(info.release, "default")) {
-		strncpy(my_uname.release, utsname()->release, __NEW_UTS_LEN);
-	} else {
-		strncpy(my_uname.release, info.release, __NEW_UTS_LEN);
-	}
-	if (!strcmp(info.version, "default")) {
-		strncpy(my_uname.version, utsname()->version, __NEW_UTS_LEN);
-	} else {
-		strncpy(my_uname.version, info.version, __NEW_UTS_LEN);
-	}
-	spin_unlock(&susfs_uname_spin_lock);
-	SUSFS_LOGI("setting spoofed release: '%s', version: '%s'\n",
-				my_uname.release, my_uname.version);
-	return 0;
-}
-
-void susfs_spoof_uname(struct new_utsname* tmp) {
-	if (unlikely(my_uname.release[0] == '\0' || spin_is_locked(&susfs_uname_spin_lock)))
-		return;
-	strncpy(tmp->release, my_uname.release, __NEW_UTS_LEN);
-	strncpy(tmp->version, my_uname.version, __NEW_UTS_LEN);
-}
-#endif // #ifdef CONFIG_KSU_SUSFS_SPOOF_UNAME
-
-/* set_log */
-#ifdef CONFIG_KSU_SUSFS_ENABLE_LOG
-void susfs_set_log(bool enabled) {
-	spin_lock(&susfs_spin_lock);
-	susfs_is_log_enabled = enabled;
-	spin_unlock(&susfs_spin_lock);
-	if (susfs_is_log_enabled) {
-		pr_info("susfs: enable logging to kernel");
-	} else {
-		pr_info("susfs: disable logging to kernel");
-	}
-}
-#endif // #ifdef CONFIG_KSU_SUSFS_ENABLE_LOG
-
-/* spoof_cmdline_or_bootconfig */
-#ifdef CONFIG_KSU_SUSFS_SPOOF_CMDLINE_OR_BOOTCONFIG
-static char *fake_cmdline_or_bootconfig = NULL;
-int susfs_set_cmdline_or_bootconfig(char* __user user_fake_cmdline_or_bootconfig) {
-	int res;
-
-	if (!fake_cmdline_or_bootconfig) {
-		// 4096 is enough I guess
-		fake_cmdline_or_bootconfig = kmalloc(SUSFS_FAKE_CMDLINE_OR_BOOTCONFIG_SIZE, GFP_KERNEL);
-		if (!fake_cmdline_or_bootconfig) {
-			SUSFS_LOGE("no enough memory\n");
-			return -ENOMEM;
-		}
-	}
-
-	spin_lock(&susfs_spin_lock);
-	memset(fake_cmdline_or_bootconfig, 0, SUSFS_FAKE_CMDLINE_OR_BOOTCONFIG_SIZE);
-	res = strncpy_from_user(fake_cmdline_or_bootconfig, user_fake_cmdline_or_bootconfig, SUSFS_FAKE_CMDLINE_OR_BOOTCONFIG_SIZE-1);
-	spin_unlock(&susfs_spin_lock);
-
-	if (res > 0) {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(6,1,0)
-		SUSFS_LOGI("fake_cmdline_or_bootconfig is set, length of string: %lu\n", strlen(fake_cmdline_or_bootconfig));
-#else
-		SUSFS_LOGI("fake_cmdline_or_bootconfig is set, length of string: %u\n", strlen(fake_cmdline_or_bootconfig));
-#endif
-		return 0;
-	}
-	SUSFS_LOGI("failed setting fake_cmdline_or_bootconfig\n");
-	return res;
-}
-
-int susfs_spoof_cmdline_or_bootconfig(struct seq_file *m) {
-	if (fake_cmdline_or_bootconfig != NULL) {
-		seq_puts(m, fake_cmdline_or_bootconfig);
-		return 0;
-	}
-	return 1;
-}
-#endif
-
-/* open_redirect */
-#ifdef CONFIG_KSU_SUSFS_OPEN_REDIRECT
-static DEFINE_HASHTABLE(OPEN_REDIRECT_HLIST, 10);
-static int susfs_update_open_redirect_inode(struct st_susfs_open_redirect_hlist *new_entry) {
-	struct path path_target;
-	struct inode *inode_target;
-	int err = 0;
-
-	err = kern_path(new_entry->target_pathname, LOOKUP_FOLLOW, &path_target);
-	if (err) {
-		SUSFS_LOGE("Failed opening file '%s'\n", new_entry->target_pathname);
-		return err;
-	}
-
-	inode_target = d_inode(path_target.dentry);
-	if (!inode_target) {
-		SUSFS_LOGE("inode_target is NULL\n");
-		err = 1;
-		goto out_path_put_target;
-	}
-
-	spin_lock(&inode_target->i_lock);
-	inode_target->i_state |= INODE_STATE_OPEN_REDIRECT;
-	spin_unlock(&inode_target->i_lock);
-
-out_path_put_target:
-	path_put(&path_target);
-	return err;
-}
-
-int susfs_add_open_redirect(struct st_susfs_open_redirect* __user user_info) {
-	struct st_susfs_open_redirect info;
-	struct st_susfs_open_redirect_hlist *new_entry, *tmp_entry;
-	struct hlist_node *tmp_node;
-	int bkt;
-	bool update_hlist = false;
-
-	if (copy_from_user(&info, user_info, sizeof(info))) {
-		SUSFS_LOGE("failed copying from userspace\n");
-		return 1;
-	}
-
-	spin_lock(&susfs_spin_lock);
-	hash_for_each_safe(OPEN_REDIRECT_HLIST, bkt, tmp_node, tmp_entry, node) {
-		if (!strcmp(tmp_entry->target_pathname, info.target_pathname)) {
-			hash_del(&tmp_entry->node);
-			kfree(tmp_entry);
-			update_hlist = true;
-			break;
-		}
-	}
-	spin_unlock(&susfs_spin_lock);
-
-	new_entry = kmalloc(sizeof(struct st_susfs_open_redirect_hlist), GFP_KERNEL);
-	if (!new_entry) {
-		SUSFS_LOGE("no enough memory\n");
-		return 1;
-	}
-
-	new_entry->target_ino = info.target_ino;
-	strncpy(new_entry->target_pathname, info.target_pathname, SUSFS_MAX_LEN_PATHNAME-1);
-	strncpy(new_entry->redirected_pathname, info.redirected_pathname, SUSFS_MAX_LEN_PATHNAME-1);
-	if (susfs_update_open_redirect_inode(new_entry)) {
-		SUSFS_LOGE("failed adding path '%s' to OPEN_REDIRECT_HLIST\n", new_entry->target_pathname);
-		kfree(new_entry);
-		return 1;
-	}
-
-	spin_lock(&susfs_spin_lock);
-	hash_add(OPEN_REDIRECT_HLIST, &new_entry->node, info.target_ino);
-	if (update_hlist) {
-		SUSFS_LOGI("target_ino: '%lu', target_pathname: '%s', redirected_pathname: '%s', is successfully updated to OPEN_REDIRECT_HLIST\n",
-				new_entry->target_ino, new_entry->target_pathname, new_entry->redirected_pathname);	
-	} else {
-		SUSFS_LOGI("target_ino: '%lu', target_pathname: '%s' redirected_pathname: '%s', is successfully added to OPEN_REDIRECT_HLIST\n",
-				new_entry->target_ino, new_entry->target_pathname, new_entry->redirected_pathname);
-	}
-	spin_unlock(&susfs_spin_lock);
-	return 0;
-}
-
-struct filename* susfs_get_redirected_path(unsigned long ino) {
-	struct st_susfs_open_redirect_hlist *entry;
-
-	hash_for_each_possible(OPEN_REDIRECT_HLIST, entry, node, ino) {
-		if (entry->target_ino == ino) {
-			SUSFS_LOGI("Redirect for ino: %lu\n", ino);
-			return getname_kernel(entry->redirected_pathname);
-		}
-	}
-	return ERR_PTR(-ENOENT);
-}
-#endif // #ifdef CONFIG_KSU_SUSFS_OPEN_REDIRECT
-
-/* sus_su */
-#ifdef CONFIG_KSU_SUSFS_SUS_SU
-bool susfs_is_sus_su_hooks_enabled __read_mostly = false;
-static int susfs_sus_su_working_mode = 0;
-extern void ksu_susfs_enable_sus_su(void);
-extern void ksu_susfs_disable_sus_su(void);
-
-int susfs_get_sus_su_working_mode(void) {
-	return susfs_sus_su_working_mode;
-}
-
-int susfs_sus_su(struct st_sus_su* __user user_info) {
-	struct st_sus_su info;
-	int last_working_mode = susfs_sus_su_working_mode;
-
-	if (copy_from_user(&info, user_info, sizeof(struct st_sus_su))) {
-		SUSFS_LOGE("failed copying from userspace\n");
-		return 1;
-	}
-
-	if (info.mode == SUS_SU_WITH_HOOKS) {
-		if (last_working_mode == SUS_SU_WITH_HOOKS) {
-			SUSFS_LOGE("current sus_su mode is already %d\n", SUS_SU_WITH_HOOKS);
-			return 1;
-		}
-		if (last_working_mode != SUS_SU_DISABLED) {
-			SUSFS_LOGE("please make sure the current sus_su mode is %d first\n", SUS_SU_DISABLED);
-			return 2;
-		}
-		ksu_susfs_enable_sus_su();
-		susfs_sus_su_working_mode = SUS_SU_WITH_HOOKS;
-		susfs_is_sus_su_hooks_enabled = true;
-		SUSFS_LOGI("core kprobe hooks for ksu are disabled!\n");
-		SUSFS_LOGI("non-kprobe hook sus_su is enabled!\n");
-		SUSFS_LOGI("sus_su mode: %d\n", SUS_SU_WITH_HOOKS);
-		return 0;
-	} else if (info.mode == SUS_SU_DISABLED) {
-		if (last_working_mode == SUS_SU_DISABLED) {
-			SUSFS_LOGE("current sus_su mode is already %d\n", SUS_SU_DISABLED);
-			return 1;
-		}
-		susfs_is_sus_su_hooks_enabled = false;
-		ksu_susfs_disable_sus_su();
-		susfs_sus_su_working_mode = SUS_SU_DISABLED;
-		if (last_working_mode == SUS_SU_WITH_HOOKS) {
-			SUSFS_LOGI("core kprobe hooks for ksu are enabled!\n");
-			goto out;
-		}
-out:
-		if (copy_to_user(user_info, &info, sizeof(info)))
-			SUSFS_LOGE("copy_to_user() failed\n");
-		return 0;
-	} else if (info.mode == SUS_SU_WITH_OVERLAY) {
-		SUSFS_LOGE("sus_su mode %d is deprecated\n", SUS_SU_WITH_OVERLAY);
-		return 1;
-	}
-	return 1;
-}
-#endif // #ifdef CONFIG_KSU_SUSFS_SUS_SU
-
-/* susfs_init */
-void susfs_init(void) {
-	spin_lock_init(&susfs_spin_lock);
-#ifdef CONFIG_KSU_SUSFS_SPOOF_UNAME
-	spin_lock_init(&susfs_uname_spin_lock);
-	susfs_my_uname_init();
-#endif
-	SUSFS_LOGI("susfs is initialized! version: " SUSFS_VERSION " \n");
-}
-
-/* No module exit is needed becuase it should never be a loadable kernel module */
-//void __init susfs_exit(void)
-
diff --git a/susfs4ksu/kernel_patches/include/linux/sus_su.h b/susfs4ksu/kernel_patches/include/linux/sus_su.h
deleted file mode 100644
index 98e8f3b..0000000
--- a/susfs4ksu/kernel_patches/include/linux/sus_su.h
+++ /dev/null
@@ -1,9 +0,0 @@
-#ifndef __KSU_H_SUS_SU
-#define __KSU_H_SUS_SU
-
-#include "../../drivers/kernelsu/core_hook.h"
-
-int sus_su_fifo_init(int *maj_dev_num, char *drv_path);
-int sus_su_fifo_exit(int *maj_dev_num, char *drv_path);
-
-#endif
diff --git a/susfs4ksu/kernel_patches/include/linux/susfs.h b/susfs4ksu/kernel_patches/include/linux/susfs.h
deleted file mode 100644
index ef31283..0000000
--- a/susfs4ksu/kernel_patches/include/linux/susfs.h
+++ /dev/null
@@ -1,186 +0,0 @@
-#ifndef KSU_SUSFS_H
-#define KSU_SUSFS_H
-
-#include <linux/version.h>
-#include <linux/types.h>
-#include <linux/utsname.h>
-#include <linux/hashtable.h>
-#include <linux/path.h>
-#include <linux/susfs_def.h>
-
-#define SUSFS_VERSION "v1.5.5"
-#if LINUX_VERSION_CODE < KERNEL_VERSION(5,0,0)
-#define SUSFS_VARIANT "NON-GKI"
-#else
-#define SUSFS_VARIANT "GKI"
-#endif
-
-/*********/
-/* MACRO */
-/*********/
-#define getname_safe(name) (name == NULL ? ERR_PTR(-EINVAL) : getname(name))
-#define putname_safe(name) (IS_ERR(name) ? NULL : putname(name))
-
-/**********/
-/* STRUCT */
-/**********/
-/* sus_path */
-#ifdef CONFIG_KSU_SUSFS_SUS_PATH
-struct st_susfs_sus_path {
-	unsigned long                    target_ino;
-	char                             target_pathname[SUSFS_MAX_LEN_PATHNAME];
-};
-
-struct st_susfs_sus_path_hlist {
-	unsigned long                    target_ino;
-	char                             target_pathname[SUSFS_MAX_LEN_PATHNAME];
-	struct hlist_node                node;
-};
-#endif
-
-/* sus_mount */
-#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
-struct st_susfs_sus_mount {
-	char                    target_pathname[SUSFS_MAX_LEN_PATHNAME];
-	unsigned long           target_dev;
-};
-
-struct st_susfs_sus_mount_list {
-	struct list_head                        list;
-	struct st_susfs_sus_mount               info;
-};
-#endif
-
-/* sus_kstat */
-#ifdef CONFIG_KSU_SUSFS_SUS_KSTAT
-struct st_susfs_sus_kstat {
-	int                     is_statically;
-	unsigned long           target_ino; // the ino after bind mounted or overlayed
-	char                    target_pathname[SUSFS_MAX_LEN_PATHNAME];
-	unsigned long           spoofed_ino;
-	unsigned long           spoofed_dev;
-	unsigned int            spoofed_nlink;
-	long long               spoofed_size;
-	long                    spoofed_atime_tv_sec;
-	long                    spoofed_mtime_tv_sec;
-	long                    spoofed_ctime_tv_sec;
-	long                    spoofed_atime_tv_nsec;
-	long                    spoofed_mtime_tv_nsec;
-	long                    spoofed_ctime_tv_nsec;
-	unsigned long           spoofed_blksize;
-	unsigned long long      spoofed_blocks;
-};
-
-struct st_susfs_sus_kstat_hlist {
-	unsigned long                           target_ino;
-	struct st_susfs_sus_kstat               info;
-	struct hlist_node                       node;
-};
-#endif
-
-/* try_umount */
-#ifdef CONFIG_KSU_SUSFS_TRY_UMOUNT
-struct st_susfs_try_umount {
-	char                    target_pathname[SUSFS_MAX_LEN_PATHNAME];
-	int                     mnt_mode;
-};
-
-struct st_susfs_try_umount_list {
-	struct list_head                        list;
-	struct st_susfs_try_umount              info;
-};
-#endif
-
-/* spoof_uname */
-#ifdef CONFIG_KSU_SUSFS_SPOOF_UNAME
-struct st_susfs_uname {
-	char        release[__NEW_UTS_LEN+1];
-	char        version[__NEW_UTS_LEN+1];
-};
-#endif
-
-/* open_redirect */
-#ifdef CONFIG_KSU_SUSFS_OPEN_REDIRECT
-struct st_susfs_open_redirect {
-	unsigned long                    target_ino;
-	char                             target_pathname[SUSFS_MAX_LEN_PATHNAME];
-	char                             redirected_pathname[SUSFS_MAX_LEN_PATHNAME];
-};
-
-struct st_susfs_open_redirect_hlist {
-	unsigned long                    target_ino;
-	char                             target_pathname[SUSFS_MAX_LEN_PATHNAME];
-	char                             redirected_pathname[SUSFS_MAX_LEN_PATHNAME];
-	struct hlist_node                node;
-};
-#endif
-
-/* sus_su */
-#ifdef CONFIG_KSU_SUSFS_SUS_SU
-struct st_sus_su {
-	int         mode;
-};
-#endif
-
-/***********************/
-/* FORWARD DECLARATION */
-/***********************/
-/* sus_path */
-#ifdef CONFIG_KSU_SUSFS_SUS_PATH
-int susfs_add_sus_path(struct st_susfs_sus_path* __user user_info);
-int susfs_sus_ino_for_filldir64(unsigned long ino);
-#endif
-/* sus_mount */
-#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
-int susfs_add_sus_mount(struct st_susfs_sus_mount* __user user_info);
-#ifdef CONFIG_KSU_SUSFS_AUTO_ADD_SUS_BIND_MOUNT
-int susfs_auto_add_sus_bind_mount(const char *pathname, struct path *path_target);
-#endif // #ifdef CONFIG_KSU_SUSFS_AUTO_ADD_SUS_BIND_MOUNT
-#ifdef CONFIG_KSU_SUSFS_AUTO_ADD_SUS_KSU_DEFAULT_MOUNT
-void susfs_auto_add_sus_ksu_default_mount(const char __user *to_pathname);
-#endif // #ifdef CONFIG_KSU_SUSFS_AUTO_ADD_SUS_KSU_DEFAULT_MOUNT
-#endif // #ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
-
-/* sus_kstat */
-#ifdef CONFIG_KSU_SUSFS_SUS_KSTAT
-int susfs_add_sus_kstat(struct st_susfs_sus_kstat* __user user_info);
-int susfs_update_sus_kstat(struct st_susfs_sus_kstat* __user user_info);
-void susfs_sus_ino_for_generic_fillattr(unsigned long ino, struct kstat *stat);
-void susfs_sus_ino_for_show_map_vma(unsigned long ino, dev_t *out_dev, unsigned long *out_ino);
-#endif
-/* try_umount */
-#ifdef CONFIG_KSU_SUSFS_TRY_UMOUNT
-int susfs_add_try_umount(struct st_susfs_try_umount* __user user_info);
-void susfs_try_umount(uid_t target_uid);
-#ifdef CONFIG_KSU_SUSFS_AUTO_ADD_TRY_UMOUNT_FOR_BIND_MOUNT
-void susfs_auto_add_try_umount_for_bind_mount(struct path *path);
-#endif // #ifdef CONFIG_KSU_SUSFS_AUTO_ADD_TRY_UMOUNT_FOR_BIND_MOUNT
-#endif // #ifdef CONFIG_KSU_SUSFS_TRY_UMOUNT
-/* spoof_uname */
-#ifdef CONFIG_KSU_SUSFS_SPOOF_UNAME
-int susfs_set_uname(struct st_susfs_uname* __user user_info);
-void susfs_spoof_uname(struct new_utsname* tmp);
-#endif
-/* set_log */
-#ifdef CONFIG_KSU_SUSFS_ENABLE_LOG
-void susfs_set_log(bool enabled);
-#endif
-/* spoof_cmdline_or_bootconfig */
-#ifdef CONFIG_KSU_SUSFS_SPOOF_CMDLINE_OR_BOOTCONFIG
-int susfs_set_cmdline_or_bootconfig(char* __user user_fake_boot_config);
-int susfs_spoof_cmdline_or_bootconfig(struct seq_file *m);
-#endif
-/* open_redirect */
-#ifdef CONFIG_KSU_SUSFS_OPEN_REDIRECT
-int susfs_add_open_redirect(struct st_susfs_open_redirect* __user user_info);
-struct filename* susfs_get_redirected_path(unsigned long ino);
-#endif
-/* sus_su */
-#ifdef CONFIG_KSU_SUSFS_SUS_SU
-int susfs_get_sus_su_working_mode(void);
-int susfs_sus_su(struct st_sus_su* __user user_info);
-#endif
-/* susfs_init */
-void susfs_init(void);
-
-#endif
diff --git a/susfs4ksu/kernel_patches/include/linux/susfs_def.h b/susfs4ksu/kernel_patches/include/linux/susfs_def.h
deleted file mode 100644
index 7442047..0000000
--- a/susfs4ksu/kernel_patches/include/linux/susfs_def.h
+++ /dev/null
@@ -1,62 +0,0 @@
-#ifndef KSU_SUSFS_DEF_H
-#define KSU_SUSFS_DEF_H
-
-#include <linux/bits.h>
-
-/********/
-/* ENUM */
-/********/
-/* shared with userspace ksu_susfs tool */
-#define CMD_SUSFS_ADD_SUS_PATH 0x55550
-#define CMD_SUSFS_ADD_SUS_MOUNT 0x55560
-#define CMD_SUSFS_ADD_SUS_KSTAT 0x55570
-#define CMD_SUSFS_UPDATE_SUS_KSTAT 0x55571
-#define CMD_SUSFS_ADD_SUS_KSTAT_STATICALLY 0x55572
-#define CMD_SUSFS_ADD_TRY_UMOUNT 0x55580
-#define CMD_SUSFS_SET_UNAME 0x55590
-#define CMD_SUSFS_ENABLE_LOG 0x555a0
-#define CMD_SUSFS_SET_CMDLINE_OR_BOOTCONFIG 0x555b0
-#define CMD_SUSFS_ADD_OPEN_REDIRECT 0x555c0
-#define CMD_SUSFS_RUN_UMOUNT_FOR_CURRENT_MNT_NS 0x555d0
-#define CMD_SUSFS_SHOW_VERSION 0x555e1
-#define CMD_SUSFS_SHOW_ENABLED_FEATURES 0x555e2
-#define CMD_SUSFS_SHOW_VARIANT 0x555e3
-#define CMD_SUSFS_SHOW_SUS_SU_WORKING_MODE 0x555e4
-#define CMD_SUSFS_IS_SUS_SU_READY 0x555f0
-#define CMD_SUSFS_SUS_SU 0x60000
-
-#define SUSFS_MAX_LEN_PATHNAME 256 // 256 should address many paths already unless you are doing some strange experimental stuff, then set your own desired length
-#define SUSFS_FAKE_CMDLINE_OR_BOOTCONFIG_SIZE 4096
-
-#define TRY_UMOUNT_DEFAULT 0 /* used by susfs_try_umount() */
-#define TRY_UMOUNT_DETACH 1 /* used by susfs_try_umount() */
-
-#define SUS_SU_DISABLED 0
-#define SUS_SU_WITH_OVERLAY 1 /* deprecated */
-#define SUS_SU_WITH_HOOKS 2
-
-#define DEFAULT_SUS_MNT_ID 100000 /* used by mount->mnt_id */
-#define DEFAULT_SUS_MNT_ID_FOR_KSU_PROC_UNSHARE 1000000 /* used by vfsmount->susfs_mnt_id_backup */
-#define DEFAULT_SUS_MNT_GROUP_ID 1000 /* used by mount->mnt_group_id */
-
-/*
- * inode->i_state => storing flag 'INODE_STATE_'
- * mount->mnt.susfs_mnt_id_backup => storing original mnt_id of normal mounts or custom sus mnt_id of sus mounts
- * task_struct->susfs_last_fake_mnt_id => storing last valid fake mnt_id
- * task_struct->susfs_task_state => storing flag 'TASK_STRUCT_'
- */
-
-#define INODE_STATE_SUS_PATH BIT(24)
-#define INODE_STATE_SUS_MOUNT BIT(25)
-#define INODE_STATE_SUS_KSTAT BIT(26)
-#define INODE_STATE_OPEN_REDIRECT BIT(27)
-
-#define TASK_STRUCT_NON_ROOT_USER_APP_PROC BIT(24)
-
-#define MAGIC_MOUNT_WORKDIR "/debug_ramdisk/workdir"
-#define DATA_ADB_UMOUNT_FOR_ZYGOTE_SYSTEM_PROCESS "/data/adb/susfs_umount_for_zygote_system_process"
-#define DATA_ADB_NO_AUTO_ADD_SUS_BIND_MOUNT "/data/adb/susfs_no_auto_add_sus_bind_mount"
-#define DATA_ADB_NO_AUTO_ADD_SUS_KSU_DEFAULT_MOUNT "/data/adb/susfs_no_auto_add_sus_ksu_default_mount"
-#define DATA_ADB_NO_AUTO_ADD_TRY_UMOUNT_FOR_BIND_MOUNT "/data/adb/susfs_no_auto_add_try_umount_for_bind_mount"
-
-#endif // #ifndef KSU_SUSFS_DEF_H
diff --git a/susfs4ksu/ksu_module_susfs/.susfs_no_auto_add_sus_bind_mount b/susfs4ksu/ksu_module_susfs/.susfs_no_auto_add_sus_bind_mount
deleted file mode 100644
index e69de29..0000000
diff --git a/susfs4ksu/ksu_module_susfs/.susfs_no_auto_add_sus_ksu_default_mount b/susfs4ksu/ksu_module_susfs/.susfs_no_auto_add_sus_ksu_default_mount
deleted file mode 100644
index e69de29..0000000
diff --git a/susfs4ksu/ksu_module_susfs/.susfs_no_auto_add_try_umount_for_bind_mount b/susfs4ksu/ksu_module_susfs/.susfs_no_auto_add_try_umount_for_bind_mount
deleted file mode 100644
index e69de29..0000000
diff --git a/susfs4ksu/ksu_module_susfs/.susfs_umount_for_zygote_system_process b/susfs4ksu/ksu_module_susfs/.susfs_umount_for_zygote_system_process
deleted file mode 100644
index e69de29..0000000
diff --git a/susfs4ksu/ksu_module_susfs/META-INF/com/google/android/update-binary b/susfs4ksu/ksu_module_susfs/META-INF/com/google/android/update-binary
deleted file mode 100644
index 28b48e5..0000000
--- a/susfs4ksu/ksu_module_susfs/META-INF/com/google/android/update-binary
+++ /dev/null
@@ -1,33 +0,0 @@
-#!/sbin/sh
-
-#################
-# Initialization
-#################
-
-umask 022
-
-# echo before loading util_functions
-ui_print() { echo "$1"; }
-
-require_new_magisk() {
-  ui_print "*******************************"
-  ui_print " Please install Magisk v20.4+! "
-  ui_print "*******************************"
-  exit 1
-}
-
-#########################
-# Load util_functions.sh
-#########################
-
-OUTFD=$2
-ZIPFILE=$3
-
-mount /data 2>/dev/null
-
-[ -f /data/adb/magisk/util_functions.sh ] || require_new_magisk
-. /data/adb/magisk/util_functions.sh
-[ $MAGISK_VER_CODE -lt 20400 ] && require_new_magisk
-
-install_module
-exit 0
diff --git a/susfs4ksu/ksu_module_susfs/META-INF/com/google/android/updater-script b/susfs4ksu/ksu_module_susfs/META-INF/com/google/android/updater-script
deleted file mode 100644
index 492be83..0000000
--- a/susfs4ksu/ksu_module_susfs/META-INF/com/google/android/updater-script
+++ /dev/null
@@ -1 +0,0 @@
-#MAGISK
\ No newline at end of file
diff --git a/susfs4ksu/ksu_module_susfs/README.md b/susfs4ksu/ksu_module_susfs/README.md
deleted file mode 100644
index eccd5e3..0000000
--- a/susfs4ksu/ksu_module_susfs/README.md
+++ /dev/null
@@ -1,19 +0,0 @@
-## A KernelSU module for SUS-FS patched kernel ##
-
-This module is used for installing a userspace helper tool called **ksu_susfs** and **sus_su** into /data/adb/ and provides a script example to communicate with SUSFS kernel
-
-- To enable umount for zygote spawned system process on boot, create a new file to `/data/adb/susfs_umount_for_zygote_system_process` and reboot.
-
-- To disable `KSU_SUSFS_AUTO_ADD_SUS_KSU_DEFAULT_MOUNT` on boot, create a new file to `/data/adb/susfs_no_auto_add_sus_ksu_default_mount` and reboot.
-
-- To disable `KSU_SUSFS_AUTO_ADD_SUS_BIND_MOUNT` on boot, create a new file to `/data/adb/susfs_no_auto_add_sus_bind_mount` and reboot.
-
-- To disable `KSU_SUSFS_AUTO_ADD_TRY_UMOUNT_FOR_BIND_MOUNT` on boot, create a new file to `/data/adb/susfs_no_auto_add_try_umount_for_bind_mount` and reboot.
-
-- To prevent a new `bind mount` from being added to `auto add try_umount`, it is suggested to do it in post-fs-data.d/ before post-fs-data.sh, and do following steps in the script:
-    1. setup proper permission on source path
-    2. add target mount path to sus_kstat
-    3. bind mount the target path
-    4. update sus_kstat on target path
-  so now it won't automatically add the path to try_umount and the mount will stay for all processes while still be hidden from mountinfo, stat and statfs
-  
diff --git a/susfs4ksu/ksu_module_susfs/customize.sh b/susfs4ksu/ksu_module_susfs/customize.sh
deleted file mode 100755
index 864910b..0000000
--- a/susfs4ksu/ksu_module_susfs/customize.sh
+++ /dev/null
@@ -1,26 +0,0 @@
-DEST_BIN_DIR=/data/adb/ksu/bin
-
-if [ ! -d ${DEST_BIN_DIR} ]; then
-	ui_print "'${DEST_BIN_DIR}' not existed, installation aborted."
-	rm -rf ${MODPATH}
-	exit 1
-fi
-
-unzip ${ZIPFILE} -d ${TMPDIR}/susfs
-
-if [ ${ARCH} = "arm64" ]; then
-	cp ${TMPDIR}/susfs/tools/ksu_susfs_arm64 ${DEST_BIN_DIR}/ksu_susfs
-	#cp ${TMPDIR}/susfs/tools/sus_su_arm64 ${DEST_BIN_DIR}/sus_su
-else
-	echo "Only arm64 is supported!"
-	exit 1
-fi
-
-chmod 755 ${DEST_BIN_DIR}/ksu_susfs
-#chmod 755 ${DEST_BIN_DIR}/sus_su
-chmod 644 ${MODPATH}/post-fs-data.sh ${MODPATH}/service.sh ${MODPATH}/uninstall.sh
-
-rm -rf ${MODPATH}/tools
-rm ${MODPATH}/customize.sh ${MODPATH}/README.md
-
-
diff --git a/susfs4ksu/ksu_module_susfs/module.prop b/susfs4ksu/ksu_module_susfs/module.prop
deleted file mode 100644
index 914d822..0000000
--- a/susfs4ksu/ksu_module_susfs/module.prop
+++ /dev/null
@@ -1,7 +0,0 @@
-id=susfs4ksu
-name=SUSFS-FOR-KERNELSU
-version=v1.5.5
-versionCode=105005
-author=simonpunk@gitlab.com
-description=An addon root hiding service for KernelSU compiled with patched kernel source.
-
diff --git a/susfs4ksu/ksu_module_susfs/post-fs-data.sh b/susfs4ksu/ksu_module_susfs/post-fs-data.sh
deleted file mode 100755
index d435007..0000000
--- a/susfs4ksu/ksu_module_susfs/post-fs-data.sh
+++ /dev/null
@@ -1,166 +0,0 @@
-#!/system/bin/sh
-PATH=/data/adb/ksu/bin:$PATH
-
-MODDIR=/data/adb/modules/susfs4ksu
-
-SUSFS_BIN=/data/adb/ksu/bin/ksu_susfs
-
-source ${MODDIR}/utils.sh
-
-## Important Notes:
-## - The following command can be run at other stages like service.sh, boot-completed.sh etc..,
-## - This module is just an demo showing how to use ksu_susfs tool to commuicate with kernel
-##
-## - for add_sus_path and add_sus_kstat if target file/dir is re-created or its ino number is changed, you have to re-run the same susfs command
-## - for add_sus_mount, if target path is umounted globally, you have to re-run the same susfs command
-##
-## - add_sus_path, add_sus_kstat, add_sus_mount and set_uname are allowed to be updated with new spoofed values
-##   that said, you can run multiple times with same target input but with different spoofed values.
-##
-## - BE CAUTIOUS that add_sus_path, add_sus_mount must be added after overlay or mounted operations on target files/direcotories,
-##   because susfs now mainly compare target's inode to determine whether it is a sus path, sus kstat or sus mount.
-##
-
-#### Hide target path and all its sub-paths from all user app processes which have no root permission granted ####
-## Make sure the target file/directory has no more overlay/mount operation on going. Or add it after it is done being overlayed or mounted ##
-# For some custom ROM #
-cat <<EOF >/dev/null
-${SUSFS_BIN} add_sus_path /system/addon.d
-${SUSFS_BIN} add_sus_path /vendor/bin/install-recovery.sh
-${SUSFS_BIN} add_sus_path /system/bin/install-recovery.sh
-EOF
-
-#### Hide the mounted path in /proc/self/[mounts|mountstat|mountinfo] for all processes ####
-## Make sure the target file/directory has no more overlay/mount operation on going. Or add it after it is done being overlayed or mounted ##
-cat <<EOF >/dev/null
-# for default ksu mounts #
-${SUSFS_BIN} add_sus_mount /data/adb/modules
-${SUSFS_BIN} add_sus_mount /debug_ramdisk
-# for host file #
-${SUSFS_BIN} add_sus_mount /system/etc/hosts
-## for lsposed, choose those that show up in your mountinfo, no need to add them all ##
-# also somehow you may need to add the source path to sus mount as well like below #
-${SUSFS_BIN} add_sus_mount /data/adb/modules/zygisk_lsposed/bin/dex2oat
-${SUSFS_BIN} add_sus_mount /data/adb/modules/zygisk_lsposed/bin/dex2oat32
-${SUSFS_BIN} add_sus_mount /data/adb/modules/zygisk_lsposed/bin/dex2oat64
-${SUSFS_BIN} add_sus_mount /system/apex/com.android.art/bin/dex2oat
-${SUSFS_BIN} add_sus_mount /system/apex/com.android.art/bin/dex2oat32
-${SUSFS_BIN} add_sus_mount /system/apex/com.android.art/bin/dex2oat64
-${SUSFS_BIN} add_sus_mount /apex/com.android.art/bin/dex2oat
-${SUSFS_BIN} add_sus_mount /apex/com.android.art/bin/dex2oat32
-${SUSFS_BIN} add_sus_mount /apex/com.android.art/bin/dex2oat64
-EOF
-
-#### Umount the mounted path for no root granted process ####
-# Please be reminded that susfs's try_umount takes precedence of ksu's try_umount #
-cat <<EOF >/dev/null
-# for /system/etc/hosts #
-${SUSFS_BIN} add_try_umount /system/etc/hosts 1
-# for lsposed, choose those that show up in your mountinfo, no need to add them all #
-${SUSFS_BIN} add_try_umount /system/apex/com.android.art/bin/dex2oat 1
-${SUSFS_BIN} add_try_umount /system/apex/com.android.art/bin/dex2oat32 1
-${SUSFS_BIN} add_try_umount /system/apex/com.android.art/bin/dex2oat64 1
-${SUSFS_BIN} add_try_umount /apex/com.android.art/bin/dex2oat 1
-${SUSFS_BIN} add_try_umount /apex/com.android.art/bin/dex2oat32 1
-${SUSFS_BIN} add_try_umount /apex/com.android.art/bin/dex2oat64 1
-EOF
-
-#### Spoof the stat of file/directory dynamically ####
-## Important Note: 
-##  - All paths set with sus_kstat and bind mounted will not be added to try_umount list
-##  - It is stronly suggested to use dynamically if the target path will be mounted
-cat <<EOF >/dev/null
-# First, clone the permission before adding to sus_kstat
-susfs_clone_perm "$MODDIR/hosts" /system/etc/hosts
-
-# Second, before bind mount your file/directory, use 'add_sus_kstat' to add the path #
-${SUSFS_BIN} add_sus_kstat '/system/etc/hosts'
-
-# Now bind mount or overlay your path #
-mount -o bind "$MODDIR/hosts" /system/etc/hosts
-
-# Finally use 'update_sus_kstat' to update the path again for the changed ino and device number #
-# update_sus_kstat updates ino, but blocks and size are remained the same as current stat #
-${SUSFS_BIN} update_sus_kstat '/system/etc/hosts'
-
-# Or if you want to fully clone the stat value from the original stat, use update_sus_kstat_full_clone instead #
-#${SUSFS_BIN} update_sus_kstat_full_clone '/system/etc/hosts'
-EOF
-
-#### Spoof the stat of file/directory statically ####
-## Important Note:
-##  - It is suggested to use statically if you don't need to mount anything but simply change the stat of a target path
-cat <<EOF >/dev/null
-Usage: ksu_susfs add_sus_kstat_statically </path/of/file_or_directory> \
-                        <ino> <dev> <nlink> <size> <atime> <atime_nsec> <mtime> <mtime_nsec> <ctime> <ctime_nsec> \
-                        <blocks> <blksize>
-${SUSFS_BIN} add_sus_kstat_statically '/system/framework/services.jar' 'default' 'default' 'default' 'default' '1230768000' '0' '1230768000' '0' '1230768000' '0' 'default' 'default'
-EOF
-
-#### Spoof the uname ####
-# you can get your uname args by running 'uname {-r|-v}' on your stock ROM #
-# pass 'default' to tell susfs to use the default value by uname #
-cat <<EOF >/dev/null
-${SUSFS_BIN} set_uname '5.15.137-android14-11-gb572b1fac135-ab11919372' '#1 SMP PREEMPT Mon Jun 3 16:35:10 UTC 2024'
-EOF
-
-#### Redirect path  ####
-# redirect hosts file to other hosts file somewhere else #
-cat <<EOF >/dev/null
-# plesae be reminded that only process with uid < 2000 is effective #
-# and before doing that, make sure you setup proper permission and selinux for your redirected file #
-susfs_clone_perm '/data/local/tmp/my_hosts' '/system/etc/hosts'
-${SUSFS_BIN} add_path_redirect '/system/etc/hosts' '/data/local/tmp/my_hosts'
-EOF
-
-#### Spoof /proc/cmdline or /proc/bootconfig ####
-# No root process detects it for now, and this spoofing won't help much actually #
-# /proc/bootconfig #
-cat <<EOF >/dev/null
-FAKE_BOOTCONFIG=${MODDIR}/fake_bootconfig.txt
-cat /proc/bootconfig > ./fake_bootconfig.txt
-sed -i 's/^androidboot.bootreason.*$/androidboot.bootreason = "reboot"/g' ${FAKE_BOOTCONFIG}
-sed -i 's/^androidboot.vbmeta.device_state.*$/androidboot.vbmeta.device_state = "locked"/g' ${FAKE_BOOTCONFIG}
-sed -i 's/^androidboot.verifiedbootstate.*$/androidboot.verifiedbootstate = "green"/g' ${FAKE_BOOTCONFIG}
-sed -i '/androidboot.verifiedbooterror/d' ${FAKE_BOOTCONFIG}
-sed -i '/androidboot.verifyerrorpart/d' ${FAKE_BOOTCONFIG}
-${SUSFS_BIN} set_cmdline_or_bootconfig /data/adb/modules/susfs4ksu/fake_bootconfig.txt
-EOF
-
-# /proc/cmdline #
-cat <<EOF >/dev/null
-FAKE_PROC_CMDLINE_FILE=${MODDIR}/fake_proc_cmdline.txt
-cat /proc/cmdline > ${FAKE_PROC_CMDLINE_FILE}
-sed -i 's/androidboot.verifiedbootstate=orange/androidboot.verifiedbootstate=green/g' ${FAKE_PROC_CMDLINE_FILE}
-sed -i 's/androidboot.vbmeta.device_state=unlocked/androidboot.vbmeta.device_state=locked/g' ${FAKE_PROC_CMDLINE_FILE}
-${SUSFS_BIN} set_cmdline_or_bootconfig ${FAKE_PROC_CMDLINE_FILE}
-EOF
-
-#### Enable sus_su (Deprecated, do NOT use it) ####
-#cat <<EOF >/dev/null
-#enable_sus_su_mode_1(){
-#	## Here we manually create an system overlay an copy the sus_su and sus_su_drv_path to ${MODDIR}/system/bin after sus_su is enabled,
-#	## as ksu overlay script is executed after all post-fs-data.sh scripts are finished
-#
-#	rm -rf ${MODDIR}/system 2>/dev/null
-#	# Enable sus_su or abort the function if sus_su is not supported #
-#	if ! ${SUSFS_BIN} sus_su 1; then
-#		return
-#	fi
-#	mkdir -p ${MODDIR}/system/bin 2>/dev/null
-#	# Copy the new generated sus_su_drv_path and 'sus_su' to /system/bin/ and rename 'sus_su' to 'su' #
-#	cp -f /data/adb/ksu/bin/sus_su ${MODDIR}/system/bin/su
-#	cp -f /data/adb/ksu/bin/sus_su_drv_path ${MODDIR}/system/bin/sus_su_drv_path
-#}
-## NOTE: mode 1 has to be run in post-fs-data.sh stage as it needs ksu default overlay mount scheme to mount the su overlay #
-## uncomment it below to enable sus_su with mode 1 #
-##enable_sus_su_mode_1
-#EOF
-
-#### Hiding the exposed /proc interface of ext4 loop and jdb2 when mounting modules.img using sus_path ####
-cat <<EOF >/dev/null
-for device in $(ls -Ld /proc/fs/jbd2/loop*8 | sed 's|/proc/fs/jbd2/||; s|-8||'); do
-	${SUSFS_BIN} add_sus_path /proc/fs/jbd2/${device}-8
-	${SUSFS_BIN} add_sus_path /proc/fs/ext4/${device}
-done
-EOF
diff --git a/susfs4ksu/ksu_module_susfs/service.sh b/susfs4ksu/ksu_module_susfs/service.sh
deleted file mode 100755
index 57ac979..0000000
--- a/susfs4ksu/ksu_module_susfs/service.sh
+++ /dev/null
@@ -1,28 +0,0 @@
-#!/system/bin/sh
-PATH=/data/adb/ksu/bin:$PATH
-
-MODDIR=/data/adb/modules/susfs4ksu
-
-SUSFS_BIN=/data/adb/ksu/bin/ksu_susfs
-
-source ${MODDIR}/utils.sh
-
-## Hexpatch prop name for newer pixel device ##
-cat <<EOF >/dev/null
-# Remember the length of search value and replace value has to be the same #
-resetprop -n "ro.boot.verifiedbooterror" "0"
-susfs_hexpatch_prop_name "ro.boot.verifiedbooterror" "verifiedbooterror" "hello_my_newworld"
-
-resetprop -n "ro.boot.verifyerrorpart" "true"
-susfs_hexpatch_prop_name "ro.boot.verifyerrorpart" "verifyerrorpart" "letsgopartyyeah"
-
-resetprop --delete "crashrecovery.rescue_boot_count"
-EOF
-
-# NOTE: sus_su 2 can be only run during or after service stage #
-# uncomment it below to enable sus_su with mode 2 #
-#${SUSFS_BIN} sus_su 2
-
-## Disable susfs kernel log ##
-#${SUSFS_BIN} enable_log 0
-
diff --git a/susfs4ksu/ksu_module_susfs/tools/ksu_susfs_arm64 b/susfs4ksu/ksu_module_susfs/tools/ksu_susfs_arm64
deleted file mode 100755
index f15e21a..0000000
Binary files a/susfs4ksu/ksu_module_susfs/tools/ksu_susfs_arm64 and /dev/null differ
diff --git a/susfs4ksu/ksu_module_susfs/uninstall.sh b/susfs4ksu/ksu_module_susfs/uninstall.sh
deleted file mode 100755
index d671eb9..0000000
--- a/susfs4ksu/ksu_module_susfs/uninstall.sh
+++ /dev/null
@@ -1,5 +0,0 @@
-{
-	rm -f /data/adb/ksu/bin/ksu_susfs
-	#rm -f /data/adb/ksu/bin/sus_su
-	#rm -f /data/adb/ksu/bin/sus_su_drv_path
-} 2>/dev/null
diff --git a/susfs4ksu/ksu_module_susfs/utils.sh b/susfs4ksu/ksu_module_susfs/utils.sh
deleted file mode 100755
index ea5be4d..0000000
--- a/susfs4ksu/ksu_module_susfs/utils.sh
+++ /dev/null
@@ -1,54 +0,0 @@
-#!/system/bin/sh
-PATH=/data/adb/ksu/bin:$PATH
-
-## susfs_clone_perm <file/or/dir/perm/to/be/changed> <file/or/dir/to/clone/from>
-susfs_clone_perm() {
-	TO=$1
-	FROM=$2
-	if [ -z "${TO}" -o -z "${FROM}" ]; then
-		return
-	fi
-	## stat https://github.com/backslashxx/bindhosts/commit/427f18fe0b212ef2754e79c8aaaa72cb59ad253d#diff-8cb0da3b1680ce3a9f3263622042aa6f0250431fa5069513664650a17c48fdabR15
-	CLONED_PERM_STRING=$(stat -c "%a %U %G" ${FROM})
-	set ${CLONED_PERM_STRING}
-	chmod $1 ${TO}
-	chown $2:$3 ${TO}
-	busybox chcon --reference=${FROM} ${TO}
-}
-
-# USAGE: susfs_hexpatch_prop_name <prop name> <search value> <replace value>
-#
-#        <search value> and <replace value> must have the same length
-# Credit: 
-#   osm0sis - https://github.com/osm0sis/PlayIntegrityFork/blob/main/module/common_func.sh
-#   changhuapeng - https://github.com/changhuapeng for making LOSPropsGoAway
-susfs_hexpatch_prop_name() {
-	local NAME="$1"
-	local CURVALUE="$2"
-	local NEWVALUE="$3"
-	[ ${#CURVALUE} -ne ${#NEWVALUE} ] && return 1
-
-	if [ -f /dev/__properties__ ]; then
-		local PROPFILE=/dev/__properties__
-	else
-		local PROPFILE="/dev/__properties__/$(resetprop -Z "$NAME")"
-	fi
-
-	if [ -f "$PROPFILE" ]; then
-		## need only the last node ##
-		NAME=${NAME##*.}
-		## Loop and remove all matched name ##
-		while true; do
-			local NAMEOFFSET=$(echo $(strings -t d "$PROPFILE" | grep "$NAME") | cut -d ' ' -f 1)
-			## here we need to make sure the NAMEOFFSET is not empty ##
-			if [ -z "${NAMEOFFSET}" ]; then
-				break
-			fi
-			local NEWSTR=$(echo "$NAME" | sed 's/'"$CURVALUE"'/'"$NEWVALUE"'/g')
-			local NAMELEN=${#NAME}
-			local NEWHEX=$(printf "$NEWSTR" | od -A n -t x1 -v | tr -d ' \n')
-			echo -ne $(printf "$NEWHEX" | sed -e 's/.\{2\}/&\\x/g' -e 's/^/\\x/' -e 's/\\x$//') | dd obs=1 count=$NAMELEN seek=$NAMEOFFSET conv=notrunc of="$PROPFILE"
-		done
-	fi
-}
-
diff --git a/susfs4ksu/ksu_susfs/jni/Android.mk b/susfs4ksu/ksu_susfs/jni/Android.mk
deleted file mode 100644
index 0d82a09..0000000
--- a/susfs4ksu/ksu_susfs/jni/Android.mk
+++ /dev/null
@@ -1,9 +0,0 @@
-LOCAL_PATH := $(call my-dir)
-
-include $(CLEAR_VARS)
-
-LOCAL_MODULE    := ksu_susfs
-LOCAL_SRC_FILES := main.c
-LOCAL_LDFLAGS := -static
-
-include $(BUILD_EXECUTABLE)
diff --git a/susfs4ksu/ksu_susfs/jni/Application.mk b/susfs4ksu/ksu_susfs/jni/Application.mk
deleted file mode 100644
index dd4b6f2..0000000
--- a/susfs4ksu/ksu_susfs/jni/Application.mk
+++ /dev/null
@@ -1,2 +0,0 @@
-APP_ABI := arm64-v8a
-APP_PLATFORM := latest
diff --git a/susfs4ksu/ksu_susfs/jni/main.c b/susfs4ksu/ksu_susfs/jni/main.c
deleted file mode 100644
index 2916c9e..0000000
--- a/susfs4ksu/ksu_susfs/jni/main.c
+++ /dev/null
@@ -1,791 +0,0 @@
-#include <stdio.h>
-#include <unistd.h>
-#include <string.h>
-#include <stdlib.h>
-#include <sys/inotify.h>
-#include <sys/prctl.h>
-#include <errno.h>
-#include <time.h>
-#include <stdbool.h>
-#include <sys/stat.h>
-#include <android/log.h>
-#include <ctype.h>
-#include <fcntl.h>
-#include <sys/sysmacros.h>
-#include <sys/vfs.h>
-
-/*************************
- ** Define Const Values **
- *************************/
-#define TAG "ksu_susfs"
-#define KERNEL_SU_OPTION 0xDEADBEEF
-
-#define CMD_SUSFS_ADD_SUS_PATH 0x55550
-#define CMD_SUSFS_ADD_SUS_MOUNT 0x55560
-#define CMD_SUSFS_ADD_SUS_KSTAT 0x55570
-#define CMD_SUSFS_UPDATE_SUS_KSTAT 0x55571
-#define CMD_SUSFS_ADD_SUS_KSTAT_STATICALLY 0x55572
-#define CMD_SUSFS_ADD_TRY_UMOUNT 0x55580
-#define CMD_SUSFS_SET_UNAME 0x55590
-#define CMD_SUSFS_ENABLE_LOG 0x555a0
-#define CMD_SUSFS_SET_CMDLINE_OR_BOOTCONFIG 0x555b0
-#define CMD_SUSFS_ADD_OPEN_REDIRECT 0x555c0
-#define CMD_SUSFS_RUN_UMOUNT_FOR_CURRENT_MNT_NS 0x555d0
-#define CMD_SUSFS_SHOW_VERSION 0x555e1
-#define CMD_SUSFS_SHOW_ENABLED_FEATURES 0x555e2
-#define CMD_SUSFS_SHOW_VARIANT 0x555e3
-#define CMD_SUSFS_SHOW_SUS_SU_WORKING_MODE 0x555e4
-#define CMD_SUSFS_IS_SUS_SU_READY 0x555f0
-#define CMD_SUSFS_SUS_SU 0x60000
-
-#define SUSFS_MAX_LEN_PATHNAME 256
-#define SUSFS_MAX_LEN_MOUNT_TYPE_NAME 32
-
-#ifndef __NEW_UTS_LEN
-#define __NEW_UTS_LEN 64
-#endif
-
-#define SUS_SU_BIN_PATH "/data/adb/ksu/bin/sus_su"
-#define SUS_SU_CONF_FILE_PATH "/data/adb/ksu/bin/sus_su_drv_path"
-#define SUS_SU_DISABLED 0
-#define SUS_SU_WITH_OVERLAY 1 /* deprecated */
-#define SUS_SU_WITH_HOOKS 2
-
-/* VM flags from linux kernel */
-#define VM_NONE		0x00000000
-#define VM_READ		0x00000001	/* currently active flags */
-#define VM_WRITE	0x00000002
-#define VM_EXEC		0x00000004
-#define VM_SHARED	0x00000008
-/* mprotect() hardcodes VM_MAYREAD >> 4 == VM_READ, and so for r/w/x bits. */
-#define VM_MAYREAD	0x00000010	/* limits for mprotect() etc */
-#define VM_MAYWRITE	0x00000020
-#define VM_MAYEXEC	0x00000040
-#define VM_MAYSHARE	0x00000080
-
-/******************
- ** Define Macro **
- ******************/
-#define log(fmt, msg...) printf(TAG ":" fmt, ##msg);
-#define PRT_MSG_IF_OPERATION_NOT_SUPPORTED(x, cmd) if (x == -1) log("[-] CMD: '0x%x', SUSFS operation not supported, please enable it in kernel\n", cmd)
-
-/*******************
- ** Define Struct **
- *******************/
-struct st_susfs_sus_path {
-	unsigned long           target_ino;
-	char                    target_pathname[SUSFS_MAX_LEN_PATHNAME];
-};
-
-struct st_susfs_sus_mount {
-	char                    target_pathname[SUSFS_MAX_LEN_PATHNAME];
-	unsigned long           target_dev;
-};
-
-struct st_susfs_sus_kstat {
-	bool                    is_statically;
-	unsigned long           target_ino; // the ino after bind mounted or overlayed
-	char                    target_pathname[SUSFS_MAX_LEN_PATHNAME];
-	unsigned long           spoofed_ino;
-	unsigned long           spoofed_dev;
-	unsigned int            spoofed_nlink;
-	long long               spoofed_size;
-	long                    spoofed_atime_tv_sec;
-	long                    spoofed_mtime_tv_sec;
-	long                    spoofed_ctime_tv_sec;
-	long                    spoofed_atime_tv_nsec;
-	long                    spoofed_mtime_tv_nsec;
-	long                    spoofed_ctime_tv_nsec;
-	unsigned long           spoofed_blksize;
-	unsigned long long      spoofed_blocks;
-};
-
-struct st_susfs_try_umount {
-	char                    target_pathname[SUSFS_MAX_LEN_PATHNAME];
-	int                     mnt_mode;
-};
-
-struct st_susfs_uname {
-	char                    release[__NEW_UTS_LEN+1];
-	char                    version[__NEW_UTS_LEN+1];
-};
-
-struct st_susfs_open_redirect {
-	unsigned long           target_ino;
-	char                    target_pathname[SUSFS_MAX_LEN_PATHNAME];
-	char                    redirected_pathname[SUSFS_MAX_LEN_PATHNAME];
-};
-
-struct st_sus_su {
-	int                     mode;
-};
-
-/**********************
- ** Define Functions **
- **********************/
-void pre_check() {
-	if (getuid() != 0) {
-		log("[-] Must run as root\n");
-		exit(1);
-	}
-}
-
-int isNumeric(char* str) {
-	// Check if the string is empty
-	if (str[0] == '\0') {
-		return 0;
-	}
-
-	// Check each character in the string
-	for (int i = 0; str[i] != '\0'; i++) {
-		// If any character is not a digit, return false
-		if (!isdigit(str[i])) {
-			return 0;
-		}
-	}
-
-	// All characters are digits, return true
-	return 1;
-}
-
-int get_file_stat(char *pathname, struct stat* sb) {
-	if (stat(pathname, sb) != 0) {
-		return 1;
-	}
-	return 0;
-}
-
-void copy_stat_to_sus_kstat(struct st_susfs_sus_kstat* info, struct stat* sb) {
-	info->spoofed_ino = sb->st_ino;
-	info->spoofed_dev = sb->st_dev;
-	info->spoofed_nlink = sb->st_nlink;
-	info->spoofed_size = sb->st_size;
-	info->spoofed_atime_tv_sec = sb->st_atime;
-	info->spoofed_mtime_tv_sec = sb->st_mtime;
-	info->spoofed_ctime_tv_sec = sb->st_ctime;
-	info->spoofed_atime_tv_nsec = sb->st_atime_nsec;
-	info->spoofed_mtime_tv_nsec = sb->st_mtime_nsec;
-	info->spoofed_ctime_tv_nsec = sb->st_ctime_nsec;
-	info->spoofed_blksize = sb->st_blksize;
-	info->spoofed_blocks = sb->st_blocks;
-}
-
-int enable_sus_su(int last_working_mode, int target_working_mode) {
-	struct st_sus_su info;
-	int error = -1;
-
-	if (target_working_mode == SUS_SU_WITH_HOOKS) {
-		info.mode = SUS_SU_WITH_HOOKS;
-		prctl(KERNEL_SU_OPTION, CMD_SUSFS_SUS_SU, &info, NULL, &error);
-		PRT_MSG_IF_OPERATION_NOT_SUPPORTED(error, CMD_SUSFS_SUS_SU);
-		if (error) {
-			if (error == 1) {
-				log("[-] current sus_su mode is already %d\n", SUS_SU_WITH_HOOKS);
-			} else if (error == 2) {
-				log("[-] please make sure the current sus_su mode is %d first\n", SUS_SU_DISABLED);
-			}
-			return error;
-		}
-		log("[+] sus_su mode 2 is enabled\n");
-	} else if (target_working_mode == SUS_SU_DISABLED) {
-		info.mode = SUS_SU_DISABLED;
-		prctl(KERNEL_SU_OPTION, CMD_SUSFS_SUS_SU, &info, NULL, &error);
-		PRT_MSG_IF_OPERATION_NOT_SUPPORTED(error, CMD_SUSFS_SUS_SU);
-		if (error) {
-			if (error == 1) {
-				log("[-] current sus_su mode is already %d\n", SUS_SU_DISABLED);
-			}
-			return error;
-		}
-		log("[+] sus_su mode 0 is enabled\n");
-	} else {
-		return 1;
-	}
-	return 0;
-}
-
-static void print_help(void) {
-	log(" usage: %s <CMD> [CMD options]\n", TAG);
-	log("    <CMD>:\n");
-	log("        add_sus_path </path/of/file_or_directory>\n");
-	log("         |--> Added path and all its sub-paths will be hidden from several syscalls\n");
-	log("         |--> Please be reminded that the target path must be added after the bind mount or overlay operation, otherwise it won't be effective\n");
-	log("\n");
-	log("        add_sus_mount <mounted_path>\n");
-	log("         |--> Added mounted path will be hidden from /proc/self/[mounts|mountinfo|mountstats]\n");
-	log("         |--> Please be reminded that the target path must be added after the bind mount or overlay operation, otherwise it won't be effective\n");
-	log("\n");
-	log("        add_sus_kstat_statically </path/of/file_or_directory> <ino> <dev> <nlink> <size>\\\n");
-	log("                                 <atime> <atime_nsec> <mtime> <mtime_nsec> <ctime> <ctime_nsec>\n");
-	log("                                 <blocks> <blksize>\n");
-	log("         |--> Use 'stat' tool to find the format:\n");
-	log("                  ino -> %%i, dev -> %%d, nlink -> %%h, atime -> %%X, mtime -> %%Y, ctime -> %%Z\n");
-	log("                  size -> %%s, blocks -> %%b, blksize -> %%B\n");
-	log("         |--> e.g., %s add_sus_kstat_statically '/system/addon.d' '1234' '1234' '2' '223344'\\\n", TAG);
-	log("                       '1712592355' '0' '1712592355' '0' '1712592355' '0' '1712592355' '0'\\\n");
-	log("                       '16' '512'\n");
-	log("         |--> Or pass 'default' to use its original value:\n");
-	log("         |--> e.g., %s add_sus_kstat_statically '/system/addon.d' 'default' 'default' 'default' 'default'\\\n", TAG);
-	log("                       '1712592355' 'default' '1712592355' 'default' '1712592355' 'default'\\\n");
-	log("                       'default' 'default'\n");
-	log("\n");
-	log("        add_sus_kstat </path/of/file_or_directory>\n");
-	log("         |--> Add the desired path BEFORE it gets bind mounted or overlayed, this is used for storing original stat info in kernel memory\n");
-	log("         |--> This command must be completed with <update_sus_kstat> later after the added path is bind mounted or overlayed\n");
-	log("\n");
-	log("        update_sus_kstat </path/of/file_or_directory>\n");
-	log("         |--> Add the desired path you have added before via <add_sus_kstat> to complete the kstat spoofing procedure\n");
-	log("         |--> This updates the target ino, but size and blocks are remained the same as current stat\n");
-	log("\n");
-	log("        update_sus_kstat_full_clone </path/of/file_or_directory>\n");
-	log("         |--> Add the desired path you have added before via <add_sus_kstat> to complete the kstat spoofing procedure\n");
-	log("         |--> This updates the target ino only, other stat members are remained the same as the original stat\n");
-	log("\n");
-	log("        add_try_umount </path/of/file_or_directory> <mode>\n");
-	log("         |--> Added path will be umounted from KSU for all UIDs that are NOT su allowed, and profile template configured with umount\n");
-	log("         |--> <mode>: 0 -> umount with no flags, 1 -> umount with MNT_DETACH\n");
-	log("         |--> NOTE: susfs umount takes precedence of ksu umount\n");
-	log("\n");
-	log("        run_try_umount\n");
-	log("         |--> Make all sus mounts to be private and umount them one by one in kernel for the mount namespace of current process\n");
-	log("\n");
-	log("        set_uname <release> <version>\n");
-	log("         |--> NOTE: Only 'release' and <version> are spoofed as others are no longer needed\n");
-	log("         |--> Spoof uname for all processes, set string to 'default' to imply the function to use original string\n");
-	log("         |--> e.g., set_uname '4.9.337-g3291538446b7' 'default'\n");
-	log("\n");
-	log("        enable_log <0|1>\n");
-	log("         |--> 0: disable susfs log in kernel, 1: enable susfs log in kernel\n");
-	log("\n");
-	log("        set_cmdline_or_bootconfig </path/to/fake_cmdline_file/or/fake_bootconfig_file>\n");
-	log("         |--> Spoof the output of /proc/cmdline (non-gki) or /proc/bootconfig (gki) from a text file\n");
-	log("\n");
-	log("        add_open_redirect </target/path> </redirected/path>\n");
-	log("         |--> Redirect the target path to be opened with user defined path\n");
-	log("\n");
-	log("        show <version|enabled_features|variant>\n");
-	log("         |--> version: show the current susfs version implemented in kernel\n");
-	log("         |--> enabled_features: show the current implemented susfs features in kernel\n");
-	log("         |--> variant: show the current variant: GKI or NON-GKI\n");
-	log("\n");
-	log("        sus_su <0|1|2|show_working_mode>\n");
-	log("         |--> NOTE-1:\n");
-	log("              - For mode 1: (deprecated) It disables kprobe hooks made by ksu, and instead,\n");
-	log("                a sus_su character device driver with random name will be created, and user\n");
-	log("                need to use a tool named 'sus_su' together with a path file in same current directory\n");
-	log("                named '" SUS_SU_CONF_FILE_PATH "' to get a root shell from the sus_su driver.'\n");
-	log("                ** sus_su userspace tool and an overlay mount is required **'\n");
-	log("              - For mode 2: It disables kprobe hooks made by ksu, and instead,\n");
-	log("                the non-kprobe inline hooks will be enbaled, just the same implementation for non-gki kernel without kprobe supported)\n");
-	log("                ** Needs no extra userspace tools and mounts **\n");
-	log("         |--> NOTE-2:\n");
-	log("                Please see the service.sh template from ksu_module_susfs for the usage\n");
-	log("         |--> 0: enable core ksu kprobe hooks and disable sus_su driver\n");
-	log("         |--> 1: (deprecated), disable the core ksu kprobe hooks and enable sus_su fifo driver\n");
-	log("         |--> 2: disable the core ksu kprobe hooks and enable sus_su just with non-kprobe hooks\n");
-	log("         |--> show_working_mode: show the current sus_su working mode, [0,1,2]\n");
-	log("\n");
-}
-
-/*******************
- ** Main Function **
- *******************/
-int main(int argc, char *argv[]) {
-	int error = -1;
-
-	pre_check();
-	// add_sus_path
-	if (argc == 3 && !strcmp(argv[1], "add_sus_path")) {
-		struct st_susfs_sus_path info = {0};
-		struct stat sb;
-
-		if (get_file_stat(argv[2], &sb)) {
-			log("%s not found, skip adding its ino\n", info.target_pathname);
-			return 1;
-		}
-		info.target_ino = sb.st_ino;
-		strncpy(info.target_pathname, argv[2], SUSFS_MAX_LEN_PATHNAME-1);
-		prctl(KERNEL_SU_OPTION, CMD_SUSFS_ADD_SUS_PATH, &info, NULL, &error);
-		PRT_MSG_IF_OPERATION_NOT_SUPPORTED(error, CMD_SUSFS_ADD_SUS_PATH);
-		return error;
-	// add_sus_mount
-	} else if (argc == 3 && !strcmp(argv[1], "add_sus_mount")) {
-		struct st_susfs_sus_mount info;
-		struct stat sb;
-
-		strncpy(info.target_pathname, argv[2], SUSFS_MAX_LEN_PATHNAME-1);
-		if (get_file_stat(argv[2], &sb)) {
-			log("[-] Failed to get stat from path: '%s'\n", argv[2]);
-			return 1;
-		}
-		info.target_dev = sb.st_dev;
-		prctl(KERNEL_SU_OPTION, CMD_SUSFS_ADD_SUS_MOUNT, &info, NULL, &error);
-		PRT_MSG_IF_OPERATION_NOT_SUPPORTED(error, CMD_SUSFS_ADD_SUS_MOUNT);
-		return error;
-	// add_sus_kstat_statically
-	} else if (argc == 15 && !strcmp(argv[1], "add_sus_kstat_statically")) {
-		struct st_susfs_sus_kstat info;
-		struct stat sb;
-		char* endptr;
-		unsigned long ino, dev, nlink, size, atime, atime_nsec, mtime, mtime_nsec, ctime, ctime_nsec, blksize;
-		long blocks;
-
-		if (get_file_stat(argv[2], &sb)) {
-			log("[-] Failed to get stat from path: '%s'\n", argv[2]);
-			return 1;
-		}
-		
-		info.is_statically = true;
-		/* ino */
-		if (strcmp(argv[3], "default")) {
-			ino = strtoul(argv[3], &endptr, 10);
-			if (*endptr != '\0') {
-				print_help();
-				return 1;
-			}
-			info.target_ino = sb.st_ino;
-			sb.st_ino = ino;
-		} else {
-			info.target_ino = sb.st_ino;
-		}
-		/* dev */
-		if (strcmp(argv[4], "default")) {
-			dev = strtoul(argv[4], &endptr, 10);
-			if (*endptr != '\0') {
-				print_help();
-				return 1;
-			}
-			sb.st_dev = dev;
-		}
-		/* nlink */
-		if (strcmp(argv[5], "default")) {
-			nlink = strtoul(argv[5], &endptr, 10);
-			if (*endptr != '\0') {
-				print_help();
-				return 1;
-			}
-			sb.st_nlink = nlink;
-		}
-		/* size */
-		if (strcmp(argv[6], "default")) {
-			size = strtoul(argv[6], &endptr, 10);
-			if (*endptr != '\0') {
-				print_help();
-				return 1;
-			}
-			sb.st_size = size;
-		}
-		/* atime */
-		if (strcmp(argv[7], "default")) {
-			atime = strtol(argv[7], &endptr, 10);
-			if (*endptr != '\0') {
-				print_help();
-				return 1;
-			}
-			sb.st_atime = atime;
-		}
-		/* atime_nsec */
-		if (strcmp(argv[8], "default")) {
-			atime_nsec = strtoul(argv[8], &endptr, 10);
-			if (*endptr != '\0') {
-				print_help();
-				return 1;
-			}
-			sb.st_atimensec = atime_nsec;
-		}
-		/* mtime */
-		if (strcmp(argv[9], "default")) {
-			mtime = strtol(argv[9], &endptr, 10);
-			if (*endptr != '\0') {
-				print_help();
-				return 1;
-			}
-			sb.st_mtime = mtime;
-		}
-		/* mtime_nsec */
-		if (strcmp(argv[10], "default")) {
-			mtime_nsec = strtoul(argv[10], &endptr, 10);
-			if (*endptr != '\0') {
-				print_help();
-				return 1;
-			}
-			sb.st_mtimensec = mtime_nsec;
-		}
-		/* ctime */
-		if (strcmp(argv[11], "default")) {
-			ctime = strtol(argv[11], &endptr, 10);
-			if (*endptr != '\0') {
-				print_help();
-				return 1;
-			}
-			sb.st_ctime = ctime;
-		}
-		/* ctime_nsec */
-		if (strcmp(argv[12], "default")) {
-			ctime_nsec = strtoul(argv[12], &endptr, 10);
-			if (*endptr != '\0') {
-				print_help();
-				return 1;
-			}
-			sb.st_ctimensec = ctime_nsec;
-		}
-		/* blocks */
-		if (strcmp(argv[13], "default")) {
-			blocks = strtoul(argv[13], &endptr, 10);
-			if (*endptr != '\0') {
-				print_help();
-				return 1;
-			}
-			sb.st_blocks = blocks;
-		}
-		/* blksize */
-		if (strcmp(argv[14], "default")) {
-			blksize = strtoul(argv[14], &endptr, 10);
-			if (*endptr != '\0') {
-				print_help();
-				return 1;
-			}
-			sb.st_blksize = blksize;
-		}
-		strncpy(info.target_pathname, argv[2], SUSFS_MAX_LEN_PATHNAME-1);
-		copy_stat_to_sus_kstat(&info, &sb);
-		prctl(KERNEL_SU_OPTION, CMD_SUSFS_ADD_SUS_KSTAT_STATICALLY, &info, NULL, &error);
-		PRT_MSG_IF_OPERATION_NOT_SUPPORTED(error, CMD_SUSFS_ADD_SUS_KSTAT_STATICALLY);
-		return error;
-	// add_sus_kstat
-	} else if (argc == 3 && !strcmp(argv[1], "add_sus_kstat")) {
-		struct st_susfs_sus_kstat info;
-		struct stat sb;
-
-		if (get_file_stat(argv[2], &sb)) {
-			log("[-] Failed to get stat from path: '%s'\n", argv[2]);
-			return 1;
-		}
-		strncpy(info.target_pathname, argv[2], SUSFS_MAX_LEN_PATHNAME-1);
-		info.is_statically = false;
-		info.target_ino = sb.st_ino;
-		copy_stat_to_sus_kstat(&info, &sb);
-		prctl(KERNEL_SU_OPTION, CMD_SUSFS_ADD_SUS_KSTAT, &info, NULL, &error);
-		PRT_MSG_IF_OPERATION_NOT_SUPPORTED(error, CMD_SUSFS_ADD_SUS_KSTAT);
-		return error;
-	// update_sus_kstat
-	} else if (argc == 3 && !strcmp(argv[1], "update_sus_kstat")) {
-		struct st_susfs_sus_kstat info = {0};
-		struct stat sb;
-
-		if (get_file_stat(argv[2], &sb)) {
-			log("[-] Failed to get stat from path: '%s'\n", argv[2]);
-			return 1;
-		}
-		strncpy(info.target_pathname, argv[2], SUSFS_MAX_LEN_PATHNAME-1);
-		info.is_statically = false;
-		info.target_ino = sb.st_ino;
-		info.spoofed_size = sb.st_size; // use the current size, not the spoofed one
-		info.spoofed_blocks = sb.st_blocks; // use the current blocks, not the spoofed one
-		prctl(KERNEL_SU_OPTION, CMD_SUSFS_UPDATE_SUS_KSTAT, &info, NULL, &error);
-		PRT_MSG_IF_OPERATION_NOT_SUPPORTED(error, CMD_SUSFS_UPDATE_SUS_KSTAT);
-		return error;
-	// update_sus_kstat_full_clone
-	} else if (argc == 3 && !strcmp(argv[1], "update_sus_kstat_full_clone")) {
-		struct st_susfs_sus_kstat info = {0};
-		struct stat sb;
-
-		if (get_file_stat(argv[2], &sb)) {
-			log("[-] Failed to get stat from path: '%s'\n", argv[2]);
-			return 1;
-		}
-		strncpy(info.target_pathname, argv[2], SUSFS_MAX_LEN_PATHNAME-1);
-		info.is_statically = false;
-		info.target_ino = sb.st_ino;
-		prctl(KERNEL_SU_OPTION, CMD_SUSFS_UPDATE_SUS_KSTAT, &info, NULL, &error);
-		PRT_MSG_IF_OPERATION_NOT_SUPPORTED(error, CMD_SUSFS_UPDATE_SUS_KSTAT);
-		return error;
-	// add_try_umount
-	} else if (argc == 4 && !strcmp(argv[1], "add_try_umount")) {
-		struct st_susfs_try_umount info;
-		char* endptr;
-		char abs_path[PATH_MAX], *p_abs_path;
-		
-		strncpy(info.target_pathname, argv[2], SUSFS_MAX_LEN_PATHNAME-1);
-		p_abs_path = realpath(info.target_pathname, abs_path);
-		if (p_abs_path == NULL) {
-			perror("realpath");
-			return 1;
-		}
-		if (!strcmp(p_abs_path, "/system") ||
-			!strcmp(p_abs_path, "/vendor") ||
-			!strcmp(p_abs_path, "/product") ||
-			!strcmp(p_abs_path, "/data/adb/modules") ||
-			!strcmp(p_abs_path, "/debug_ramdisk") ||
-			!strcmp(p_abs_path, "/sbin")) {
-			log("[-] %s cannot be added to try_umount, because it will be umounted by ksu lastly\n", p_abs_path);
-			return 1;
-		}
-		if (strcmp(argv[3], "0") && strcmp(argv[3], "1")) {
-			print_help();
-			return 1;
-		}
-		info.mnt_mode = strtol(argv[3], &endptr, 10);
-		if (*endptr != '\0') {
-			print_help();
-			return 1;
-		}
-		prctl(KERNEL_SU_OPTION, CMD_SUSFS_ADD_TRY_UMOUNT, &info, NULL, &error);
-		PRT_MSG_IF_OPERATION_NOT_SUPPORTED(error, CMD_SUSFS_ADD_TRY_UMOUNT);
-		return error;
-	// run_try_umount
-	} else if (argc == 2 && !strcmp(argv[1], "run_try_umount")) {
-		prctl(KERNEL_SU_OPTION, CMD_SUSFS_RUN_UMOUNT_FOR_CURRENT_MNT_NS, NULL, NULL, &error);
-		PRT_MSG_IF_OPERATION_NOT_SUPPORTED(error, CMD_SUSFS_RUN_UMOUNT_FOR_CURRENT_MNT_NS);
-		return error;
-	// set_uname
-	} else if (argc == 4 && !strcmp(argv[1], "set_uname")) {
-		struct st_susfs_uname info;
-		
-		strncpy(info.release, argv[2], __NEW_UTS_LEN);
-		strncpy(info.version, argv[3], __NEW_UTS_LEN);
-		prctl(KERNEL_SU_OPTION, CMD_SUSFS_SET_UNAME, &info, NULL, &error);
-		PRT_MSG_IF_OPERATION_NOT_SUPPORTED(error, CMD_SUSFS_SET_UNAME);
-		return error;
-	// enable_log
-	} else if (argc == 3 && !strcmp(argv[1], "enable_log")) {
-		if (strcmp(argv[2], "0") && strcmp(argv[2], "1")) {
-			print_help();
-			return 1;
-		}
-		prctl(KERNEL_SU_OPTION, CMD_SUSFS_ENABLE_LOG, atoi(argv[2]), NULL, &error);
-		PRT_MSG_IF_OPERATION_NOT_SUPPORTED(error, CMD_SUSFS_ENABLE_LOG);
-		return error;
-	// set_cmdline_or_bootconfig
-	} else if (argc == 3 && !strcmp(argv[1], "set_cmdline_or_bootconfig")) {
-		char abs_path[PATH_MAX], *p_abs_path, *buffer;
-		FILE *file;
-		long file_size;
-		size_t result; 
-
-		p_abs_path = realpath(argv[2], abs_path);
-		if (p_abs_path == NULL) {
-			perror("realpath");
-			return 1;
-		}
-		file = fopen(abs_path, "rb");
-		if (file == NULL) {
-			perror("Error opening file");
-			return 1;
-		}
-		fseek(file, 0, SEEK_END);
-		file_size = ftell(file);
-		rewind(file);
-		buffer = (char *)malloc(sizeof(char) * (file_size + 1));
-		if (buffer == NULL) {
-			perror("No enough memory");
-			fclose(file);
-			return 1;
-		}
-		result = fread(buffer, 1, file_size, file);
-		if (result != file_size) {
-			perror("Reading error");
-			fclose(file);
-			free(buffer);
-			return 1;
-		}
-		buffer[file_size] = '\0';
-		fclose(file);
-		prctl(KERNEL_SU_OPTION, CMD_SUSFS_SET_CMDLINE_OR_BOOTCONFIG, buffer, NULL, &error);
-		free(buffer);
-		PRT_MSG_IF_OPERATION_NOT_SUPPORTED(error, CMD_SUSFS_SET_CMDLINE_OR_BOOTCONFIG);
-		return error;
-	// add_open_redirect
-	} else if (argc == 4 && !strcmp(argv[1], "add_open_redirect")) {
-		struct st_susfs_open_redirect info;
-		struct stat sb;
-		char target_pathname[PATH_MAX], *p_abs_target_pathname;
-		char redirected_pathname[PATH_MAX], *p_abs_redirected_pathname;
-
-		p_abs_target_pathname = realpath(argv[2], target_pathname);
-		if (p_abs_target_pathname == NULL) {
-			perror("realpath");
-			return 1;
-		}
-		strncpy(info.target_pathname, target_pathname, SUSFS_MAX_LEN_PATHNAME-1);
-		p_abs_redirected_pathname = realpath(argv[3], redirected_pathname);
-		if (p_abs_redirected_pathname == NULL) {
-			perror("realpath");
-			return 1;
-		}
-		strncpy(info.redirected_pathname, redirected_pathname, SUSFS_MAX_LEN_PATHNAME-1);
-		if (get_file_stat(info.target_pathname, &sb)) {
-			log("[-] Failed to get stat from path: '%s'\n", info.target_pathname);
-			return 1;
-		}
-		info.target_ino = sb.st_ino;
-		prctl(KERNEL_SU_OPTION, CMD_SUSFS_ADD_OPEN_REDIRECT, &info, NULL, &error);
-		PRT_MSG_IF_OPERATION_NOT_SUPPORTED(error, CMD_SUSFS_ADD_OPEN_REDIRECT);
-		return error;
-	// show
-	} else if (argc == 3 && !strcmp(argv[1], "show")) {
-		if (!strcmp(argv[2], "version")) {
-			char version[16];
-			prctl(KERNEL_SU_OPTION, CMD_SUSFS_SHOW_VERSION, version, NULL, &error);
-			PRT_MSG_IF_OPERATION_NOT_SUPPORTED(error, CMD_SUSFS_SHOW_VERSION);
-			if (!error)
-				printf("%s\n", version);
-		} else if (!strcmp(argv[2], "enabled_features")) {
-			char *enabled_features_buf = malloc(getpagesize()*2);
-			char *ptr_buf;
-			unsigned long enabled_features;
-			int str_len;
-			if (!enabled_features_buf) {
-				perror("malloc");
-				return -ENOMEM;
-			}
-			ptr_buf = enabled_features_buf;
-			prctl(KERNEL_SU_OPTION, CMD_SUSFS_SHOW_ENABLED_FEATURES, &enabled_features, NULL, &error);
-			PRT_MSG_IF_OPERATION_NOT_SUPPORTED(error, CMD_SUSFS_SHOW_ENABLED_FEATURES);
-			if (!error) {
-				if (enabled_features & (1 << 0)) {
-					str_len = strlen("CONFIG_KSU_SUSFS_SUS_PATH\n");
-					strncpy(ptr_buf, "CONFIG_KSU_SUSFS_SUS_PATH\n", str_len);
-					ptr_buf += str_len;
-				}
-				if (enabled_features & (1 << 1)) {
-					str_len = strlen("CONFIG_KSU_SUSFS_SUS_MOUNT\n");
-					strncpy(ptr_buf, "CONFIG_KSU_SUSFS_SUS_MOUNT\n", str_len);
-					ptr_buf += str_len;
-				}
-				if (enabled_features & (1 << 2)) {
-					str_len = strlen("CONFIG_KSU_SUSFS_AUTO_ADD_SUS_KSU_DEFAULT_MOUNT\n");
-					strncpy(ptr_buf, "CONFIG_KSU_SUSFS_AUTO_ADD_SUS_KSU_DEFAULT_MOUNT\n", str_len);
-					ptr_buf += str_len;
-				}
-				if (enabled_features & (1 << 3)) {
-					str_len = strlen("CONFIG_KSU_SUSFS_AUTO_ADD_SUS_BIND_MOUNT\n");
-					strncpy(ptr_buf, "CONFIG_KSU_SUSFS_AUTO_ADD_SUS_BIND_MOUNT\n", str_len);
-					ptr_buf += str_len;
-				}
-				if (enabled_features & (1 << 4)) {
-					str_len = strlen("CONFIG_KSU_SUSFS_SUS_KSTAT\n");
-					strncpy(ptr_buf, "CONFIG_KSU_SUSFS_SUS_KSTAT\n", str_len);
-					ptr_buf += str_len;
-				}
-				if (enabled_features & (1 << 5)) {
-					str_len = strlen("CONFIG_KSU_SUSFS_SUS_OVERLAYFS\n");
-					strncpy(ptr_buf, "CONFIG_KSU_SUSFS_SUS_OVERLAYFS\n", str_len);
-					ptr_buf += str_len;
-				}
-				if (enabled_features & (1 << 6)) {
-					str_len = strlen("CONFIG_KSU_SUSFS_TRY_UMOUNT\n");
-					strncpy(ptr_buf, "CONFIG_KSU_SUSFS_TRY_UMOUNT\n", str_len);
-					ptr_buf += str_len;
-				}
-				if (enabled_features & (1 << 7)) {
-					str_len = strlen("CONFIG_KSU_SUSFS_AUTO_ADD_TRY_UMOUNT_FOR_BIND_MOUNT\n");
-					strncpy(ptr_buf, "CONFIG_KSU_SUSFS_AUTO_ADD_TRY_UMOUNT_FOR_BIND_MOUNT\n", str_len);
-					ptr_buf += str_len;
-				}
-				if (enabled_features & (1 << 8)) {
-					str_len = strlen("CONFIG_KSU_SUSFS_SPOOF_UNAME\n");
-					strncpy(ptr_buf, "CONFIG_KSU_SUSFS_SPOOF_UNAME\n", str_len);
-					ptr_buf += str_len;
-				}
-				if (enabled_features & (1 << 9)) {
-					str_len = strlen("CONFIG_KSU_SUSFS_ENABLE_LOG\n");
-					strncpy(ptr_buf, "CONFIG_KSU_SUSFS_ENABLE_LOG\n", str_len);
-					ptr_buf += str_len;
-				}
-				if (enabled_features & (1 << 10)) {
-					str_len = strlen("CONFIG_KSU_SUSFS_HIDE_KSU_SUSFS_SYMBOLS\n");
-					strncpy(ptr_buf, "CONFIG_KSU_SUSFS_HIDE_KSU_SUSFS_SYMBOLS\n", str_len);
-					ptr_buf += str_len;
-				}
-				if (enabled_features & (1 << 11)) {
-					str_len = strlen("CONFIG_KSU_SUSFS_SPOOF_CMDLINE_OR_BOOTCONFIG\n");
-					strncpy(ptr_buf, "CONFIG_KSU_SUSFS_SPOOF_CMDLINE_OR_BOOTCONFIG\n", str_len);
-					ptr_buf += str_len;
-				}
-				if (enabled_features & (1 << 12)) {
-					str_len = strlen("CONFIG_KSU_SUSFS_OPEN_REDIRECT\n");
-					strncpy(ptr_buf, "CONFIG_KSU_SUSFS_OPEN_REDIRECT\n", str_len);
-					ptr_buf += str_len;
-				}
-				if (enabled_features & (1 << 13)) {
-					str_len = strlen("CONFIG_KSU_SUSFS_SUS_SU\n");
-					strncpy(ptr_buf, "CONFIG_KSU_SUSFS_SUS_SU\n", str_len);
-					ptr_buf += str_len;
-				}
-				if (enabled_features & (1 << 14)) {
-					str_len = strlen("CONFIG_KSU_SUSFS_HAS_MAGIC_MOUNT\n");
-					strncpy(ptr_buf, "CONFIG_KSU_SUSFS_HAS_MAGIC_MOUNT\n", str_len);
-					ptr_buf += str_len;
-				}
-				printf("%s", enabled_features_buf);
-				free(enabled_features_buf);
-			}
-		} else if (!strcmp(argv[2], "variant")) {
-			char variant[16];
-			prctl(KERNEL_SU_OPTION, CMD_SUSFS_SHOW_VARIANT, variant, NULL, &error);
-			PRT_MSG_IF_OPERATION_NOT_SUPPORTED(error, CMD_SUSFS_SHOW_VARIANT);
-			if (!error)
-				printf("%s\n", variant);
-		}
-		return error;
-	// sus_su
-	} else if (argc == 3 && !strcmp(argv[1], "sus_su")) {
-		int last_working_mode = 0;
-		int target_working_mode;
-		char* endptr;
-
-		prctl(KERNEL_SU_OPTION, CMD_SUSFS_SHOW_SUS_SU_WORKING_MODE, &last_working_mode, NULL, &error);
-		PRT_MSG_IF_OPERATION_NOT_SUPPORTED(error, CMD_SUSFS_SHOW_SUS_SU_WORKING_MODE);
-		if (error)
-			return error;
-		if (!strcmp(argv[2], "show_working_mode")) {
-			printf("%d\n", last_working_mode);
-			return 0;
-		}
-		target_working_mode = strtol(argv[2], &endptr, 10);
-		if (*endptr != '\0') {
-			print_help();
-			return 1;
-		}
-		if (target_working_mode == SUS_SU_WITH_HOOKS) {
-			bool is_sus_su_ready;
-			prctl(KERNEL_SU_OPTION, CMD_SUSFS_IS_SUS_SU_READY, &is_sus_su_ready, NULL, &error);
-			PRT_MSG_IF_OPERATION_NOT_SUPPORTED(error, CMD_SUSFS_IS_SUS_SU_READY);
-			if (error)
-				return error;
-			if (!is_sus_su_ready) {
-				log("[-] sus_su mode %d has to be run during or after service stage\n", SUS_SU_WITH_HOOKS);
-				return 1;
-			}
-			if (last_working_mode == SUS_SU_DISABLED) {
-				error = enable_sus_su(last_working_mode, SUS_SU_WITH_HOOKS);
-			} else if (last_working_mode == SUS_SU_WITH_HOOKS) {
-				log("[-] sus_su is already in mode %d\n", last_working_mode);
-				return 1;
-			} else {
-				error = enable_sus_su(last_working_mode, SUS_SU_DISABLED);
-				if (!error)
-					error = enable_sus_su(last_working_mode, SUS_SU_WITH_HOOKS);
-			}
-		} else if (target_working_mode == SUS_SU_DISABLED) {
-			if (last_working_mode == SUS_SU_DISABLED) {
-				log("[-] sus_su is already in mode %d\n", last_working_mode);
-				return 1;
-			}
-			error = enable_sus_su(last_working_mode, SUS_SU_DISABLED);
-		} else if (target_working_mode == SUS_SU_WITH_OVERLAY) {
-				log("[-] sus_su mode %d is deprecated\n", SUS_SU_WITH_OVERLAY);
-				return 1;
-		} else {
-			print_help();
-			return 1;
-		}
-		return error;
-	} else {
-		print_help();
-	}
-out:
-	return 0;
-}
-
diff --git a/susfs4ksu/sus_su/jni/Android.mk b/susfs4ksu/sus_su/jni/Android.mk
deleted file mode 100644
index 1e282d7..0000000
--- a/susfs4ksu/sus_su/jni/Android.mk
+++ /dev/null
@@ -1,9 +0,0 @@
-LOCAL_PATH := $(call my-dir)
-
-include $(CLEAR_VARS)
-
-LOCAL_MODULE    := sus_su
-LOCAL_SRC_FILES := main.c
-LOCAL_LDFLAGS := -static
-
-include $(BUILD_EXECUTABLE)
diff --git a/susfs4ksu/sus_su/jni/Application.mk b/susfs4ksu/sus_su/jni/Application.mk
deleted file mode 100644
index dd4b6f2..0000000
--- a/susfs4ksu/sus_su/jni/Application.mk
+++ /dev/null
@@ -1,2 +0,0 @@
-APP_ABI := arm64-v8a
-APP_PLATFORM := latest
diff --git a/susfs4ksu/sus_su/jni/main.c b/susfs4ksu/sus_su/jni/main.c
deleted file mode 100644
index e9d6283..0000000
--- a/susfs4ksu/sus_su/jni/main.c
+++ /dev/null
@@ -1,131 +0,0 @@
-#include <stdio.h>
-#include <string.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <sys/wait.h>
-
-#define FIFO_SIZE 1024
-#define EXTRA_PATH_ENV "/data/adb/ksu/bin:/data/data/com.termux/files/usr/bin"
-#define SUS_SU_CONF_FILE "/system/bin/sus_su_drv_path"
-
-static const char *sus_su_token = "!@#$SU_IS_SUS$#@!-pRE6W9BKXrJr1hEKyvDq0CvWziVKbatT8yzq06fhtrEGky2tVS7Q2QTjhtMfVMGV";
-
-extern char **environ;
-
-static char **get_new_envp(void) {
-    const char *additional_paths = EXTRA_PATH_ENV;
-
-	// Count existing environment variables
-    int env_count = 0;
-    while (environ[env_count] != NULL) {
-        env_count++;
-    }
-
-	// Allocate space for new environment (existing + custom PATH + NULL terminator)
-    char **new_environ = malloc((env_count + 2) * sizeof(char *));
-    if (new_environ == NULL) {
-        perror("malloc");
-        return NULL;
-    }
-
-	// Copy existing environment variables
-    for (int i = 0; i < env_count; i++) {
-        new_environ[i] = environ[i];
-    }
-	
-	// Get current 'PATH' value
-	const char *orig_path_env = getenv("PATH");
-    if (orig_path_env == NULL) {
-        perror("PATH environment variable not found");
-        return NULL;
-    }
-	
-	// Calc size of new 'PATH'
-    size_t new_path_env_size = strlen(orig_path_env) + strlen(additional_paths) + 7; /* 5 for 'PATH=', 1 for ':', 1 for '\0' */
-
-	// Allocate buffer for new 'PATH'
-    char *new_path_env_buf = malloc(new_path_env_size);
-    if (new_path_env_buf == NULL) {
-        perror("Failed to allocate memory\n");
-        return NULL;
-    }
-	
-    snprintf(new_path_env_buf, new_path_env_size, "PATH=%s:%s", orig_path_env, additional_paths);
-	
-	new_environ[env_count] = new_path_env_buf;
-	new_environ[env_count + 1] = NULL; // NULL-terminated array
-
-	return new_environ;
-}
-
-static int req_root_shell(void) {
-	int fd;
-    char read_buf[FIFO_SIZE];
-	char drv_path[256] = {0};
-    ssize_t bytes;
-	int res;
-
-	fd = open(SUS_SU_CONF_FILE, O_RDONLY | O_CLOEXEC);
-    if (fd < 0) {
-        printf("Failed to open '%s'\n", SUS_SU_CONF_FILE);
-        return 1;
-    }
-	
-	res = read(fd, drv_path, 255);
-	if (res < 0) {
-        perror("Failed to read\n");
-		return 1;
-	}
-
-	close(fd);
-
-    fd = open(drv_path, O_RDWR | O_CLOEXEC);
-    if (fd < 0) {
-        perror("Failed to open device");
-        return 1;
-    }
-
-    bytes = write(fd, sus_su_token, sizeof(sus_su_token));
-    if (bytes < 0) {
-        perror("Failed to write to device");
-        close(fd);
-        return 1;
-    }
-
-    close(fd);
-	
-	if (getuid() != 0) {
-        printf("Failed to get root shell\n");
-		return 1;
-	}
-
-	printf("Thanks for using sus-su!\n");
-    return 0;
-}
-
-int main(int argc, char *argv[]) {
-    char *args[argc+1];
-    char sh[] = "/system/bin/sh";
-	char **new_envp = get_new_envp();
-
-	if (!new_envp) {
-		printf("Failed to get new envp\n");
-	}
-
-    for(int i=1; i<argc; i++) {
-        args[i] = argv[i]; 
-    }
-
-    args[0] = sh;
-    args[argc] = NULL;
-
-	if (!req_root_shell()) {
-		return execve(sh, args, new_envp);
-	}
-    
-    return 1;
-}
-
-
